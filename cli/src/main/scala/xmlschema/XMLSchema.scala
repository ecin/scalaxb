// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
/**  
    Part 1 version: Id: structures.xsd,v 1.2 2004/01/15 11:34:25 ht Exp 
    Part 2 version: Id: datatypes.xsd,v 1.3 2004/01/23 18:11:13 ht Exp 
  
*/

package xmlschema

/**  
       This type is extended by almost all schema types
       to allow attributes from other namespaces to be
       added to user schemas.
     
*/
trait XOpenAttrsable {
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


/**  
       This type is extended by almost all schema types
       to allow attributes from other namespaces to be
       added to user schemas.
     
*/
case class XOpenAttrs(attributes: Map[String, scalaxb.DataRecord[Any]]) extends XOpenAttrsable


/**  
       This type is extended by all types which allow annotation
       other than <schema> itself
     
*/
trait XAnnotatedable extends XOpenAttrsable {
  val annotation: Option[xmlschema.XAnnotation]
  val id: Option[String]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


/**  
       This type is extended by all types which allow annotation
       other than <schema> itself
     
*/
case class XAnnotated(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable

trait XFormChoice

object XFormChoice {
  def fromString(value: String): XFormChoice = value match {
    case "qualified" => XQualified
    case "unqualified" => XUnqualified

  }
}

case object XQualified extends XFormChoice { override def toString = "qualified" }
case object XUnqualified extends XFormChoice { override def toString = "unqualified" }

trait XReducedDerivationControl

object XReducedDerivationControl {
  def fromString(value: String): XReducedDerivationControl = value match {
    case "extension" => XExtensionValue2
    case "restriction" => XRestrictionValue3

  }
}

case object XExtensionValue2 extends XReducedDerivationControl { override def toString = "extension" }
case object XRestrictionValue3 extends XReducedDerivationControl { override def toString = "restriction" }

trait XTypeDerivationControl

object XTypeDerivationControl {
  def fromString(value: String): XTypeDerivationControl = value match {
    case "extension" => XExtensionValue
    case "restriction" => XRestrictionValue2
    case "list" => XListValue2
    case "union" => XUnionValue2

  }
}

case object XExtensionValue extends XTypeDerivationControl { override def toString = "extension" }
case object XRestrictionValue2 extends XTypeDerivationControl { override def toString = "restriction" }
case object XListValue2 extends XTypeDerivationControl { override def toString = "list" }
case object XUnionValue2 extends XTypeDerivationControl { override def toString = "union" }


/** 
*/
case class XSchema(xschemaoption: Seq[scalaxb.DataRecord[xmlschema.XSchemaOption]],
  xschemasequence1: Seq[xmlschema.XSchemaSequence1],
  targetNamespace: Option[java.net.URI],
  version: Option[String],
  finalDefault: String,
  blockDefault: String,
  attributeFormDefault: xmlschema.XFormChoice,
  elementFormDefault: xmlschema.XFormChoice,
  id: Option[String],
  xmllang: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XOpenAttrsable

trait XSchemaOption
case class XSchemaSequence1(arg1: scalaxb.DataRecord[Any],
  annotation: Seq[xmlschema.XAnnotation])

trait XUse

object XUse {
  def fromString(value: String): XUse = value match {
    case "prohibited" => XProhibited
    case "optional" => XOptional
    case "required" => XRequired

  }
}

case object XProhibited extends XUse { override def toString = "prohibited" }
case object XOptional extends XUse { override def toString = "optional" }
case object XRequired extends XUse { override def toString = "required" }


trait XAttributable extends XAnnotatedable with XAttrDeclsOption1 {
  val annotation: Option[xmlschema.XAnnotation]
  val simpleType: Option[xmlschema.XLocalSimpleType]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val typeValue: Option[javax.xml.namespace.QName]
  val use: xmlschema.XUse
  val default: Option[String]
  val fixed: Option[String]
  val form: Option[xmlschema.XFormChoice]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XAttribute(annotation: Option[xmlschema.XAnnotation],
  simpleType: Option[xmlschema.XLocalSimpleType],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  typeValue: Option[javax.xml.namespace.QName],
  use: xmlschema.XUse,
  default: Option[String],
  fixed: Option[String],
  form: Option[xmlschema.XFormChoice],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAttributable


case class XTopLevelAttribute(annotation: Option[xmlschema.XAnnotation],
  simpleType: Option[xmlschema.XLocalSimpleType],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  typeValue: Option[javax.xml.namespace.QName],
  use: xmlschema.XUse,
  default: Option[String],
  fixed: Option[String],
  form: Option[xmlschema.XFormChoice],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAttributable with XSchemaTopOption


trait XComplexType extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: scalaxb.DataRecord[xmlschema.XComplexTypeModelOption]
  val id: Option[String]
  val name: Option[String]
  val mixed: Boolean
  val abstractValue: Boolean
  val finalValue: Option[String]
  val block: Option[String]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XTopLevelComplexType(annotation: Option[xmlschema.XAnnotation],
  arg1: scalaxb.DataRecord[xmlschema.XComplexTypeModelOption],
  id: Option[String],
  name: Option[String],
  mixed: Boolean,
  abstractValue: Boolean,
  finalValue: Option[String],
  block: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XComplexType with XRedefinableOption


case class XLocalComplexType(annotation: Option[xmlschema.XAnnotation],
  arg1: scalaxb.DataRecord[xmlschema.XComplexTypeModelOption],
  id: Option[String],
  name: Option[String],
  mixed: Boolean,
  abstractValue: Boolean,
  finalValue: Option[String],
  block: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XComplexType with XElementOption with XTopLevelElementOption with XLocalElementableOption with XNarrowMaxMinOption


trait XRestrictionTypable extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val xrestrictiontypableoption: Option[scalaxb.DataRecord[Any]]
  val arg2: xmlschema.XAttrDeclsSequence
  val id: Option[String]
  val base: javax.xml.namespace.QName
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XRestrictionType(annotation: Option[xmlschema.XAnnotation],
  xrestrictiontypableoption: Option[scalaxb.DataRecord[Any]],
  arg2: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  base: javax.xml.namespace.QName,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XRestrictionTypable

trait XRestrictionTypableOption

case class XComplexRestrictionType(annotation: Option[xmlschema.XAnnotation],
  xrestrictiontypableoption: Option[scalaxb.DataRecord[Any]],
  arg2: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  base: javax.xml.namespace.QName,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XRestrictionTypable with XComplexContentOption

trait XComplexRestrictionTypeOption

trait XExtensionTypable extends XAnnotatedable with XComplexContentOption {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: Option[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]]
  val arg2: xmlschema.XAttrDeclsSequence
  val id: Option[String]
  val base: javax.xml.namespace.QName
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XExtensionType(annotation: Option[xmlschema.XAnnotation],
  arg1: Option[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]],
  arg2: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  base: javax.xml.namespace.QName,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XExtensionTypable


/** 
*/
case class XComplexContent(annotation: Option[xmlschema.XAnnotation],
  xcomplexcontentoption: scalaxb.DataRecord[xmlschema.XComplexContentOption],
  id: Option[String],
  mixed: Option[Boolean],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XComplexTypeModelOption

trait XComplexContentOption

case class XSimpleRestrictionType(annotation: Option[xmlschema.XAnnotation],
  xrestrictiontypableoption: Option[scalaxb.DataRecord[Any]],
  arg2: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  base: javax.xml.namespace.QName,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XRestrictionTypable with XSimpleContentOption

trait XSimpleRestrictionTypeOption

case class XSimpleExtensionType(annotation: Option[xmlschema.XAnnotation],
  arg1: Option[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]],
  arg2: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  base: javax.xml.namespace.QName,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XExtensionTypable with XSimpleContentOption


/** 
*/
case class XSimpleContent(annotation: Option[xmlschema.XAnnotation],
  xsimplecontentoption: scalaxb.DataRecord[xmlschema.XSimpleContentOption],
  id: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XComplexTypeModelOption

trait XSimpleContentOption

/**  
   The element element can be used either
   at the top level to define an element-type binding globally,
   or within a content model to either reference a globally-defined
   element or type or declare an element-type binding locally.
   The ref form is not allowed at the top level.
*/
trait XElement extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val xelementoption: Option[scalaxb.DataRecord[xmlschema.XElementOption]]
  val arg2: Seq[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val typeValue: Option[javax.xml.namespace.QName]
  val substitutionGroup: Option[javax.xml.namespace.QName]
  val minOccurs: Int
  val maxOccurs: String
  val default: Option[String]
  val fixed: Option[String]
  val nillable: Boolean
  val abstractValue: Boolean
  val finalValue: Option[String]
  val block: Option[String]
  val form: Option[xmlschema.XFormChoice]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}

trait XElementOption

case class XTopLevelElement(annotation: Option[xmlschema.XAnnotation],
  xelementoption: Option[scalaxb.DataRecord[xmlschema.XElementOption]],
  arg2: Seq[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  typeValue: Option[javax.xml.namespace.QName],
  substitutionGroup: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  default: Option[String],
  fixed: Option[String],
  nillable: Boolean,
  abstractValue: Boolean,
  finalValue: Option[String],
  block: Option[String],
  form: Option[xmlschema.XFormChoice],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XElement with XSchemaTopOption

trait XTopLevelElementOption

trait XLocalElementable extends XElement with XNestedParticleOption with XParticleOption {
  val annotation: Option[xmlschema.XAnnotation]
  val xelementoption: Option[scalaxb.DataRecord[xmlschema.XElementOption]]
  val arg2: Seq[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val typeValue: Option[javax.xml.namespace.QName]
  val substitutionGroup: Option[javax.xml.namespace.QName]
  val minOccurs: Int
  val maxOccurs: String
  val default: Option[String]
  val fixed: Option[String]
  val nillable: Boolean
  val abstractValue: Boolean
  val finalValue: Option[String]
  val block: Option[String]
  val form: Option[xmlschema.XFormChoice]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XLocalElement(annotation: Option[xmlschema.XAnnotation],
  xelementoption: Option[scalaxb.DataRecord[xmlschema.XElementOption]],
  arg2: Seq[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  typeValue: Option[javax.xml.namespace.QName],
  substitutionGroup: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  default: Option[String],
  fixed: Option[String],
  nillable: Boolean,
  abstractValue: Boolean,
  finalValue: Option[String],
  block: Option[String],
  form: Option[xmlschema.XFormChoice],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XLocalElementable

trait XLocalElementableOption

/**  
   group type for explicit groups, named top-level groups and
   group references
*/
trait XGroup extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val minOccurs: Int
  val maxOccurs: String
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


trait XRealGroupable extends XGroup {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val minOccurs: Int
  val maxOccurs: String
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XRealGroup(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XRealGroupable

trait XRealGroupableOption

case class XAll(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAllable with XNamedGroupOption


case class XNamedGroup(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XRealGroupable with XRedefinableOption

trait XNamedGroupOption

case class XGroupRef(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XRealGroupable with XTypeDefParticleOption with XNestedParticleOption with XParticleOption


/**  
   group type for the three kinds of group
*/
trait XExplicitGroupable extends XGroup with XTypeDefParticleOption with XNestedParticleOption with XParticleOption with XRealGroupableOption {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val minOccurs: Int
  val maxOccurs: String
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


/**  
   group type for the three kinds of group
*/
case class XExplicitGroup(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XExplicitGroupable


case class XSimpleExplicitGroup(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XExplicitGroupable with XNamedGroupOption

trait XMinOccurs

object XMinOccurs {
  def fromString(value: String): XMinOccurs = value match {
    case "0" => X0
    case "1" => X1

  }
}

case object X0 extends XMinOccurs { override def toString = "0" }
case object X1 extends XMinOccurs { override def toString = "1" }

trait XMaxOccurs

object XMaxOccurs {
  def fromString(value: String): XMaxOccurs = value match {
    case "0" => X0Value
    case "1" => X1Value

  }
}

case object X0Value extends XMaxOccurs { override def toString = "0" }
case object X1Value extends XMaxOccurs { override def toString = "1" }


/** restricted max/min
*/
case class XNarrowMaxMin(annotation: Option[xmlschema.XAnnotation],
  xelementoption: Option[scalaxb.DataRecord[xmlschema.XElementOption]],
  arg2: Seq[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  typeValue: Option[javax.xml.namespace.QName],
  substitutionGroup: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  default: Option[String],
  fixed: Option[String],
  nillable: Boolean,
  abstractValue: Boolean,
  finalValue: Option[String],
  block: Option[String],
  form: Option[xmlschema.XFormChoice],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XLocalElementable with XAllModelOption1

trait XNarrowMaxMinOption
trait XMinOccursType

object XMinOccursType {
  def fromString(value: String): XMinOccursType = value match {
    case "0" => X0Value2
    case "1" => X1Value2

  }
}

case object X0Value2 extends XMinOccursType { override def toString = "0" }
case object X1Value2 extends XMinOccursType { override def toString = "1" }

trait XMaxOccursType

object XMaxOccursType {
  def fromString(value: String): XMaxOccursType = value match {
    case "1" => X1Value3

  }
}

case object X1Value3 extends XMaxOccursType { override def toString = "1" }


/**  
   Only elements allowed inside
*/
trait XAllable extends XExplicitGroupable with XTypeDefParticleOption with XParticleOption with XRealGroupableOption {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]]
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val minOccurs: Int
  val maxOccurs: String
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


/**  
   Only elements allowed inside
*/
case class XAllType(annotation: Option[xmlschema.XAnnotation],
  arg1: Seq[scalaxb.DataRecord[xmlschema.XParticleOption]],
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAllable

trait XProcessContents

object XProcessContents {
  def fromString(value: String): XProcessContents = value match {
    case "skip" => XSkip
    case "lax" => XLax
    case "strict" => XStrict

  }
}

case object XSkip extends XProcessContents { override def toString = "skip" }
case object XLax extends XProcessContents { override def toString = "lax" }
case object XStrict extends XProcessContents { override def toString = "strict" }


trait XWildcardable extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val id: Option[String]
  val namespace: String
  val processContents: xmlschema.XProcessContents
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XWildcard(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  namespace: String,
  processContents: xmlschema.XProcessContents,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XWildcardable


/** 
*/
case class XAny(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  namespace: String,
  processContents: xmlschema.XProcessContents,
  minOccurs: Int,
  maxOccurs: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XWildcardable with XNestedParticleOption with XParticleOption


trait XAttributeGroup extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: xmlschema.XAttrDeclsSequence
  val id: Option[String]
  val name: Option[String]
  val ref: Option[javax.xml.namespace.QName]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XNamedAttributeGroup(annotation: Option[xmlschema.XAnnotation],
  arg1: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAttributeGroup with XRedefinableOption


case class XAttributeGroupRef(annotation: Option[xmlschema.XAnnotation],
  arg1: xmlschema.XAttrDeclsSequence,
  id: Option[String],
  name: Option[String],
  ref: Option[javax.xml.namespace.QName],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAttributeGroup with XAttrDeclsOption1


/** 
*/
case class XInclude(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  schemaLocation: java.net.URI,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XSchemaOption


/** 
*/
case class XRedefine(xredefineoption: Seq[scalaxb.DataRecord[Any]],
  schemaLocation: java.net.URI,
  id: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XOpenAttrsable with XSchemaOption

trait XRedefineOption

/** 
*/
case class XImport(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  namespace: Option[java.net.URI],
  schemaLocation: Option[java.net.URI],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XSchemaOption


/** 
*/
case class XSelector(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  xpath: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable


/** 
*/
case class XField(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  xpath: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable


trait XKeybasable extends XAnnotatedable with XIdentityConstraintOption {
  val annotation: Option[xmlschema.XAnnotation]
  val selector: xmlschema.XSelector
  val field: Seq[xmlschema.XField]
  val id: Option[String]
  val name: String
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XKeybase(annotation: Option[xmlschema.XAnnotation],
  selector: xmlschema.XSelector,
  field: Seq[xmlschema.XField],
  id: Option[String],
  name: String,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XKeybasable


/** 
*/
case class XKeyref(annotation: Option[xmlschema.XAnnotation],
  selector: xmlschema.XSelector,
  field: Seq[xmlschema.XField],
  id: Option[String],
  name: String,
  refer: javax.xml.namespace.QName,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XKeybasable with XIdentityConstraintOption


/** 
*/
case class XNotation(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  name: String,
  public: Option[String],
  system: Option[java.net.URI],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XSchemaTopOption


/** 
*/
case class XAppinfo(mixed: Seq[scalaxb.DataRecord[Any]],
  source: Option[java.net.URI],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotationOption


/** 
*/
case class XDocumentation(mixed: Seq[scalaxb.DataRecord[Any]],
  source: Option[java.net.URI],
  xmllang: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotationOption


/** 
*/
case class XAnnotation(xannotationoption: Seq[scalaxb.DataRecord[xmlschema.XAnnotationOption]],
  id: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XOpenAttrsable with XSchemaOption with XRedefineOption

trait XAnnotationOption

/**  
   Not the real urType, but as close an approximation as we can
   get in the XML representation
*/
case class XAnyType(mixed: Seq[scalaxb.DataRecord[Any]],
  attributes: Map[String, scalaxb.DataRecord[Any]])

trait XDerivationControl

object XDerivationControl {
  def fromString(value: String): XDerivationControl = value match {
    case "substitution" => XSubstitution
    case "extension" => XExtension
    case "restriction" => XRestrictionValue
    case "list" => XListValue
    case "union" => XUnionValue

  }
}

case object XSubstitution extends XDerivationControl { override def toString = "substitution" }
case object XExtension extends XDerivationControl { override def toString = "extension" }
case object XRestrictionValue extends XDerivationControl { override def toString = "restriction" }
case object XListValue extends XDerivationControl { override def toString = "list" }
case object XUnionValue extends XDerivationControl { override def toString = "union" }


trait XSimpleType extends XAnnotatedable {
  val annotation: Option[xmlschema.XAnnotation]
  val arg1: scalaxb.DataRecord[xmlschema.XSimpleDerivationOption]
  val id: Option[String]
  val finalValue: Option[String]
  val name: Option[String]
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XTopLevelSimpleType(annotation: Option[xmlschema.XAnnotation],
  arg1: scalaxb.DataRecord[xmlschema.XSimpleDerivationOption],
  id: Option[String],
  finalValue: Option[String],
  name: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XSimpleType with XRedefinableOption


case class XLocalSimpleType(annotation: Option[xmlschema.XAnnotation],
  arg1: scalaxb.DataRecord[xmlschema.XSimpleDerivationOption],
  id: Option[String],
  finalValue: Option[String],
  name: Option[String],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XSimpleType with XElementOption with XTopLevelElementOption with XLocalElementableOption with XNarrowMaxMinOption


case class XRestriction(annotation: Option[xmlschema.XAnnotation],
  arg1: xmlschema.XSimpleRestrictionModelSequence,
  id: Option[String],
  base: Option[javax.xml.namespace.QName],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XSimpleDerivationOption


case class XList(annotation: Option[xmlschema.XAnnotation],
  simpleType: Option[xmlschema.XLocalSimpleType],
  id: Option[String],
  itemType: Option[javax.xml.namespace.QName],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XSimpleDerivationOption


case class XUnion(annotation: Option[xmlschema.XAnnotation],
  simpleType: Seq[xmlschema.XLocalSimpleType],
  id: Option[String],
  memberTypes: Option[Seq[javax.xml.namespace.QName]],
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XAnnotatedable with XSimpleDerivationOption


trait XFacetable extends XAnnotatedable with XFacetsOption {
  val annotation: Option[xmlschema.XAnnotation]
  val id: Option[String]
  val value: String
  val fixed: Boolean
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XFacet(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  value: String,
  fixed: Boolean,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XFacetable


trait XNoFixedFacetable extends XFacetable with XFacetsOption {
  val annotation: Option[xmlschema.XAnnotation]
  val id: Option[String]
  val value: String
  val fixed: Boolean
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XNoFixedFacet(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  value: String,
  fixed: Boolean,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XNoFixedFacetable


trait XNumFacetable extends XFacetable with XFacetsOption {
  val annotation: Option[xmlschema.XAnnotation]
  val id: Option[String]
  val value: String
  val fixed: Boolean
  val attributes: Map[String, scalaxb.DataRecord[Any]]
}


case class XNumFacet(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  value: String,
  fixed: Boolean,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XNumFacetable


/** 
*/
case class XTotalDigits(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  value: String,
  fixed: Boolean,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XNumFacetable with XFacetsOption

trait XValue

object XValue {
  def fromString(value: String): XValue = value match {
    case "preserve" => XPreserve
    case "replace" => XReplace
    case "collapse" => XCollapse

  }
}

case object XPreserve extends XValue { override def toString = "preserve" }
case object XReplace extends XValue { override def toString = "replace" }
case object XCollapse extends XValue { override def toString = "collapse" }


/** 
*/
case class XWhiteSpace(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  value: String,
  fixed: Boolean,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XFacetable with XFacetsOption


/** 
*/
case class XPattern(annotation: Option[xmlschema.XAnnotation],
  id: Option[String],
  value: String,
  fixed: Boolean,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends XNoFixedFacetable with XFacetsOption

case class XSimpleRestrictionModelSequence(simpleType: Option[xmlschema.XLocalSimpleType],
  arg2: Seq[scalaxb.DataRecord[xmlschema.XFacetsOption]])

trait XFacetsOption
trait XSimpleDerivationOption
trait XIdentityConstraintOption
case class XAllModelSequence(annotation: Option[xmlschema.XAnnotation],
  xallmodeloption1: Seq[scalaxb.DataRecord[xmlschema.XNarrowMaxMin]])

trait XAllModelOption1
trait XComplexTypeModelOption
case class XComplexTypeModelSequence1(arg1: Option[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]],
  arg2: xmlschema.XAttrDeclsSequence) extends XComplexTypeModelOption

case class XAttrDeclsSequence(xattrdeclsoption1: Seq[scalaxb.DataRecord[xmlschema.XAttrDeclsOption1]],
  anyAttribute: Option[xmlschema.XWildcardable])

trait XAttrDeclsOption1
trait XParticleOption
trait XNestedParticleOption
trait XTypeDefParticleOption
trait XRedefinableOption
trait XSchemaTopOption

/**  
   for element, group and attributeGroup,
   which both define and reference
*/
case class XDefRef(name: Option[String],
  ref: Option[javax.xml.namespace.QName])


/**  
   for all particles
*/
case class XOccurs(minOccurs: Int,
  maxOccurs: String)

