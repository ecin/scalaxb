// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package xmlschema
    
/**
usage:
import scalaxb._
import Scalaxb._
import xmlschema._
import DefaultXXMLProtocol._

val obj = fromXML[Foo](node)
val document = toXML[Foo](obj, "foo", defaultScope)
**/
trait XXMLProtocol extends scalaxb.XMLStandardTypes {
  implicit lazy val XmlschemaXOpenAttrsableFormat: scalaxb.XMLFormat[xmlschema.XOpenAttrsable] = buildXmlschemaXOpenAttrsableFormat
  def buildXmlschemaXOpenAttrsableFormat: scalaxb.XMLFormat[xmlschema.XOpenAttrsable]

  implicit lazy val XmlschemaXOpenAttrsFormat: scalaxb.XMLFormat[xmlschema.XOpenAttrs] = buildXmlschemaXOpenAttrsFormat
  def buildXmlschemaXOpenAttrsFormat: scalaxb.XMLFormat[xmlschema.XOpenAttrs]

  implicit lazy val XmlschemaXAnnotatedableFormat: scalaxb.XMLFormat[xmlschema.XAnnotatedable] = buildXmlschemaXAnnotatedableFormat
  def buildXmlschemaXAnnotatedableFormat: scalaxb.XMLFormat[xmlschema.XAnnotatedable]

  implicit lazy val XmlschemaXAnnotatedFormat: scalaxb.XMLFormat[xmlschema.XAnnotated] = buildXmlschemaXAnnotatedFormat
  def buildXmlschemaXAnnotatedFormat: scalaxb.XMLFormat[xmlschema.XAnnotated]

  implicit lazy val XmlschemaXFormChoiceFormat: scalaxb.XMLFormat[xmlschema.XFormChoice] = buildXmlschemaXFormChoiceFormat
  def buildXmlschemaXFormChoiceFormat: scalaxb.XMLFormat[xmlschema.XFormChoice]

  implicit lazy val XmlschemaXReducedDerivationControlFormat: scalaxb.XMLFormat[xmlschema.XReducedDerivationControl] = buildXmlschemaXReducedDerivationControlFormat
  def buildXmlschemaXReducedDerivationControlFormat: scalaxb.XMLFormat[xmlschema.XReducedDerivationControl]

  implicit lazy val XmlschemaXTypeDerivationControlFormat: scalaxb.XMLFormat[xmlschema.XTypeDerivationControl] = buildXmlschemaXTypeDerivationControlFormat
  def buildXmlschemaXTypeDerivationControlFormat: scalaxb.XMLFormat[xmlschema.XTypeDerivationControl]

  implicit lazy val XmlschemaXSchemaFormat: scalaxb.XMLFormat[xmlschema.XSchema] = buildXmlschemaXSchemaFormat
  def buildXmlschemaXSchemaFormat: scalaxb.XMLFormat[xmlschema.XSchema]

  implicit lazy val XmlschemaXSchemaSequence1Format: scalaxb.XMLFormat[xmlschema.XSchemaSequence1] = buildXmlschemaXSchemaSequence1Format
  def buildXmlschemaXSchemaSequence1Format: scalaxb.XMLFormat[xmlschema.XSchemaSequence1]

  implicit lazy val XmlschemaXUseFormat: scalaxb.XMLFormat[xmlschema.XUse] = buildXmlschemaXUseFormat
  def buildXmlschemaXUseFormat: scalaxb.XMLFormat[xmlschema.XUse]

  implicit lazy val XmlschemaXAttributableFormat: scalaxb.XMLFormat[xmlschema.XAttributable] = buildXmlschemaXAttributableFormat
  def buildXmlschemaXAttributableFormat: scalaxb.XMLFormat[xmlschema.XAttributable]

  implicit lazy val XmlschemaXAttributeFormat: scalaxb.XMLFormat[xmlschema.XAttribute] = buildXmlschemaXAttributeFormat
  def buildXmlschemaXAttributeFormat: scalaxb.XMLFormat[xmlschema.XAttribute]

  implicit lazy val XmlschemaXTopLevelAttributeFormat: scalaxb.XMLFormat[xmlschema.XTopLevelAttribute] = buildXmlschemaXTopLevelAttributeFormat
  def buildXmlschemaXTopLevelAttributeFormat: scalaxb.XMLFormat[xmlschema.XTopLevelAttribute]

  implicit lazy val XmlschemaXComplexTypeFormat: scalaxb.XMLFormat[xmlschema.XComplexType] = buildXmlschemaXComplexTypeFormat
  def buildXmlschemaXComplexTypeFormat: scalaxb.XMLFormat[xmlschema.XComplexType]

  implicit lazy val XmlschemaXTopLevelComplexTypeFormat: scalaxb.XMLFormat[xmlschema.XTopLevelComplexType] = buildXmlschemaXTopLevelComplexTypeFormat
  def buildXmlschemaXTopLevelComplexTypeFormat: scalaxb.XMLFormat[xmlschema.XTopLevelComplexType]

  implicit lazy val XmlschemaXLocalComplexTypeFormat: scalaxb.XMLFormat[xmlschema.XLocalComplexType] = buildXmlschemaXLocalComplexTypeFormat
  def buildXmlschemaXLocalComplexTypeFormat: scalaxb.XMLFormat[xmlschema.XLocalComplexType]

  implicit lazy val XmlschemaXRestrictionTypableFormat: scalaxb.XMLFormat[xmlschema.XRestrictionTypable] = buildXmlschemaXRestrictionTypableFormat
  def buildXmlschemaXRestrictionTypableFormat: scalaxb.XMLFormat[xmlschema.XRestrictionTypable]

  implicit lazy val XmlschemaXRestrictionTypeFormat: scalaxb.XMLFormat[xmlschema.XRestrictionType] = buildXmlschemaXRestrictionTypeFormat
  def buildXmlschemaXRestrictionTypeFormat: scalaxb.XMLFormat[xmlschema.XRestrictionType]

  implicit lazy val XmlschemaXComplexRestrictionTypeFormat: scalaxb.XMLFormat[xmlschema.XComplexRestrictionType] = buildXmlschemaXComplexRestrictionTypeFormat
  def buildXmlschemaXComplexRestrictionTypeFormat: scalaxb.XMLFormat[xmlschema.XComplexRestrictionType]

  implicit lazy val XmlschemaXExtensionTypableFormat: scalaxb.XMLFormat[xmlschema.XExtensionTypable] = buildXmlschemaXExtensionTypableFormat
  def buildXmlschemaXExtensionTypableFormat: scalaxb.XMLFormat[xmlschema.XExtensionTypable]

  implicit lazy val XmlschemaXExtensionTypeFormat: scalaxb.XMLFormat[xmlschema.XExtensionType] = buildXmlschemaXExtensionTypeFormat
  def buildXmlschemaXExtensionTypeFormat: scalaxb.XMLFormat[xmlschema.XExtensionType]

  implicit lazy val XmlschemaXComplexContentFormat: scalaxb.XMLFormat[xmlschema.XComplexContent] = buildXmlschemaXComplexContentFormat
  def buildXmlschemaXComplexContentFormat: scalaxb.XMLFormat[xmlschema.XComplexContent]

  implicit lazy val XmlschemaXSimpleRestrictionTypeFormat: scalaxb.XMLFormat[xmlschema.XSimpleRestrictionType] = buildXmlschemaXSimpleRestrictionTypeFormat
  def buildXmlschemaXSimpleRestrictionTypeFormat: scalaxb.XMLFormat[xmlschema.XSimpleRestrictionType]

  implicit lazy val XmlschemaXSimpleExtensionTypeFormat: scalaxb.XMLFormat[xmlschema.XSimpleExtensionType] = buildXmlschemaXSimpleExtensionTypeFormat
  def buildXmlschemaXSimpleExtensionTypeFormat: scalaxb.XMLFormat[xmlschema.XSimpleExtensionType]

  implicit lazy val XmlschemaXSimpleContentFormat: scalaxb.XMLFormat[xmlschema.XSimpleContent] = buildXmlschemaXSimpleContentFormat
  def buildXmlschemaXSimpleContentFormat: scalaxb.XMLFormat[xmlschema.XSimpleContent]

  implicit lazy val XmlschemaXElementFormat: scalaxb.XMLFormat[xmlschema.XElement] = buildXmlschemaXElementFormat
  def buildXmlschemaXElementFormat: scalaxb.XMLFormat[xmlschema.XElement]

  implicit lazy val XmlschemaXTopLevelElementFormat: scalaxb.XMLFormat[xmlschema.XTopLevelElement] = buildXmlschemaXTopLevelElementFormat
  def buildXmlschemaXTopLevelElementFormat: scalaxb.XMLFormat[xmlschema.XTopLevelElement]

  implicit lazy val XmlschemaXLocalElementableFormat: scalaxb.XMLFormat[xmlschema.XLocalElementable] = buildXmlschemaXLocalElementableFormat
  def buildXmlschemaXLocalElementableFormat: scalaxb.XMLFormat[xmlschema.XLocalElementable]

  implicit lazy val XmlschemaXLocalElementFormat: scalaxb.XMLFormat[xmlschema.XLocalElement] = buildXmlschemaXLocalElementFormat
  def buildXmlschemaXLocalElementFormat: scalaxb.XMLFormat[xmlschema.XLocalElement]

  implicit lazy val XmlschemaXGroupFormat: scalaxb.XMLFormat[xmlschema.XGroup] = buildXmlschemaXGroupFormat
  def buildXmlschemaXGroupFormat: scalaxb.XMLFormat[xmlschema.XGroup]

  implicit lazy val XmlschemaXRealGroupableFormat: scalaxb.XMLFormat[xmlschema.XRealGroupable] = buildXmlschemaXRealGroupableFormat
  def buildXmlschemaXRealGroupableFormat: scalaxb.XMLFormat[xmlschema.XRealGroupable]

  implicit lazy val XmlschemaXRealGroupFormat: scalaxb.XMLFormat[xmlschema.XRealGroup] = buildXmlschemaXRealGroupFormat
  def buildXmlschemaXRealGroupFormat: scalaxb.XMLFormat[xmlschema.XRealGroup]

  implicit lazy val XmlschemaXAllFormat: scalaxb.XMLFormat[xmlschema.XAll] = buildXmlschemaXAllFormat
  def buildXmlschemaXAllFormat: scalaxb.XMLFormat[xmlschema.XAll]

  implicit lazy val XmlschemaXNamedGroupFormat: scalaxb.XMLFormat[xmlschema.XNamedGroup] = buildXmlschemaXNamedGroupFormat
  def buildXmlschemaXNamedGroupFormat: scalaxb.XMLFormat[xmlschema.XNamedGroup]

  implicit lazy val XmlschemaXGroupRefFormat: scalaxb.XMLFormat[xmlschema.XGroupRef] = buildXmlschemaXGroupRefFormat
  def buildXmlschemaXGroupRefFormat: scalaxb.XMLFormat[xmlschema.XGroupRef]

  implicit lazy val XmlschemaXExplicitGroupableFormat: scalaxb.XMLFormat[xmlschema.XExplicitGroupable] = buildXmlschemaXExplicitGroupableFormat
  def buildXmlschemaXExplicitGroupableFormat: scalaxb.XMLFormat[xmlschema.XExplicitGroupable]

  implicit lazy val XmlschemaXExplicitGroupFormat: scalaxb.XMLFormat[xmlschema.XExplicitGroup] = buildXmlschemaXExplicitGroupFormat
  def buildXmlschemaXExplicitGroupFormat: scalaxb.XMLFormat[xmlschema.XExplicitGroup]

  implicit lazy val XmlschemaXSimpleExplicitGroupFormat: scalaxb.XMLFormat[xmlschema.XSimpleExplicitGroup] = buildXmlschemaXSimpleExplicitGroupFormat
  def buildXmlschemaXSimpleExplicitGroupFormat: scalaxb.XMLFormat[xmlschema.XSimpleExplicitGroup]

  implicit lazy val XmlschemaXMinOccursFormat: scalaxb.XMLFormat[xmlschema.XMinOccurs] = buildXmlschemaXMinOccursFormat
  def buildXmlschemaXMinOccursFormat: scalaxb.XMLFormat[xmlschema.XMinOccurs]

  implicit lazy val XmlschemaXMaxOccursFormat: scalaxb.XMLFormat[xmlschema.XMaxOccurs] = buildXmlschemaXMaxOccursFormat
  def buildXmlschemaXMaxOccursFormat: scalaxb.XMLFormat[xmlschema.XMaxOccurs]

  implicit lazy val XmlschemaXNarrowMaxMinFormat: scalaxb.XMLFormat[xmlschema.XNarrowMaxMin] = buildXmlschemaXNarrowMaxMinFormat
  def buildXmlschemaXNarrowMaxMinFormat: scalaxb.XMLFormat[xmlschema.XNarrowMaxMin]

  implicit lazy val XmlschemaXMinOccursTypeFormat: scalaxb.XMLFormat[xmlschema.XMinOccursType] = buildXmlschemaXMinOccursTypeFormat
  def buildXmlschemaXMinOccursTypeFormat: scalaxb.XMLFormat[xmlschema.XMinOccursType]

  implicit lazy val XmlschemaXMaxOccursTypeFormat: scalaxb.XMLFormat[xmlschema.XMaxOccursType] = buildXmlschemaXMaxOccursTypeFormat
  def buildXmlschemaXMaxOccursTypeFormat: scalaxb.XMLFormat[xmlschema.XMaxOccursType]

  implicit lazy val XmlschemaXAllableFormat: scalaxb.XMLFormat[xmlschema.XAllable] = buildXmlschemaXAllableFormat
  def buildXmlschemaXAllableFormat: scalaxb.XMLFormat[xmlschema.XAllable]

  implicit lazy val XmlschemaXAllTypeFormat: scalaxb.XMLFormat[xmlschema.XAllType] = buildXmlschemaXAllTypeFormat
  def buildXmlschemaXAllTypeFormat: scalaxb.XMLFormat[xmlschema.XAllType]

  implicit lazy val XmlschemaXProcessContentsFormat: scalaxb.XMLFormat[xmlschema.XProcessContents] = buildXmlschemaXProcessContentsFormat
  def buildXmlschemaXProcessContentsFormat: scalaxb.XMLFormat[xmlschema.XProcessContents]

  implicit lazy val XmlschemaXWildcardableFormat: scalaxb.XMLFormat[xmlschema.XWildcardable] = buildXmlschemaXWildcardableFormat
  def buildXmlschemaXWildcardableFormat: scalaxb.XMLFormat[xmlschema.XWildcardable]

  implicit lazy val XmlschemaXWildcardFormat: scalaxb.XMLFormat[xmlschema.XWildcard] = buildXmlschemaXWildcardFormat
  def buildXmlschemaXWildcardFormat: scalaxb.XMLFormat[xmlschema.XWildcard]

  implicit lazy val XmlschemaXAnyFormat: scalaxb.XMLFormat[xmlschema.XAny] = buildXmlschemaXAnyFormat
  def buildXmlschemaXAnyFormat: scalaxb.XMLFormat[xmlschema.XAny]

  implicit lazy val XmlschemaXAttributeGroupFormat: scalaxb.XMLFormat[xmlschema.XAttributeGroup] = buildXmlschemaXAttributeGroupFormat
  def buildXmlschemaXAttributeGroupFormat: scalaxb.XMLFormat[xmlschema.XAttributeGroup]

  implicit lazy val XmlschemaXNamedAttributeGroupFormat: scalaxb.XMLFormat[xmlschema.XNamedAttributeGroup] = buildXmlschemaXNamedAttributeGroupFormat
  def buildXmlschemaXNamedAttributeGroupFormat: scalaxb.XMLFormat[xmlschema.XNamedAttributeGroup]

  implicit lazy val XmlschemaXAttributeGroupRefFormat: scalaxb.XMLFormat[xmlschema.XAttributeGroupRef] = buildXmlschemaXAttributeGroupRefFormat
  def buildXmlschemaXAttributeGroupRefFormat: scalaxb.XMLFormat[xmlschema.XAttributeGroupRef]

  implicit lazy val XmlschemaXIncludeFormat: scalaxb.XMLFormat[xmlschema.XInclude] = buildXmlschemaXIncludeFormat
  def buildXmlschemaXIncludeFormat: scalaxb.XMLFormat[xmlschema.XInclude]

  implicit lazy val XmlschemaXRedefineFormat: scalaxb.XMLFormat[xmlschema.XRedefine] = buildXmlschemaXRedefineFormat
  def buildXmlschemaXRedefineFormat: scalaxb.XMLFormat[xmlschema.XRedefine]

  implicit lazy val XmlschemaXImportFormat: scalaxb.XMLFormat[xmlschema.XImport] = buildXmlschemaXImportFormat
  def buildXmlschemaXImportFormat: scalaxb.XMLFormat[xmlschema.XImport]

  implicit lazy val XmlschemaXSelectorFormat: scalaxb.XMLFormat[xmlschema.XSelector] = buildXmlschemaXSelectorFormat
  def buildXmlschemaXSelectorFormat: scalaxb.XMLFormat[xmlschema.XSelector]

  implicit lazy val XmlschemaXFieldFormat: scalaxb.XMLFormat[xmlschema.XField] = buildXmlschemaXFieldFormat
  def buildXmlschemaXFieldFormat: scalaxb.XMLFormat[xmlschema.XField]

  implicit lazy val XmlschemaXKeybasableFormat: scalaxb.XMLFormat[xmlschema.XKeybasable] = buildXmlschemaXKeybasableFormat
  def buildXmlschemaXKeybasableFormat: scalaxb.XMLFormat[xmlschema.XKeybasable]

  implicit lazy val XmlschemaXKeybaseFormat: scalaxb.XMLFormat[xmlschema.XKeybase] = buildXmlschemaXKeybaseFormat
  def buildXmlschemaXKeybaseFormat: scalaxb.XMLFormat[xmlschema.XKeybase]

  implicit lazy val XmlschemaXKeyrefFormat: scalaxb.XMLFormat[xmlschema.XKeyref] = buildXmlschemaXKeyrefFormat
  def buildXmlschemaXKeyrefFormat: scalaxb.XMLFormat[xmlschema.XKeyref]

  implicit lazy val XmlschemaXNotationFormat: scalaxb.XMLFormat[xmlschema.XNotation] = buildXmlschemaXNotationFormat
  def buildXmlschemaXNotationFormat: scalaxb.XMLFormat[xmlschema.XNotation]

  implicit lazy val XmlschemaXAppinfoFormat: scalaxb.XMLFormat[xmlschema.XAppinfo] = buildXmlschemaXAppinfoFormat
  def buildXmlschemaXAppinfoFormat: scalaxb.XMLFormat[xmlschema.XAppinfo]

  implicit lazy val XmlschemaXDocumentationFormat: scalaxb.XMLFormat[xmlschema.XDocumentation] = buildXmlschemaXDocumentationFormat
  def buildXmlschemaXDocumentationFormat: scalaxb.XMLFormat[xmlschema.XDocumentation]

  implicit lazy val XmlschemaXAnnotationFormat: scalaxb.XMLFormat[xmlschema.XAnnotation] = buildXmlschemaXAnnotationFormat
  def buildXmlschemaXAnnotationFormat: scalaxb.XMLFormat[xmlschema.XAnnotation]

  implicit lazy val XmlschemaXAnyTypeFormat: scalaxb.XMLFormat[xmlschema.XAnyType] = buildXmlschemaXAnyTypeFormat
  def buildXmlschemaXAnyTypeFormat: scalaxb.XMLFormat[xmlschema.XAnyType]

  implicit lazy val XmlschemaXDerivationControlFormat: scalaxb.XMLFormat[xmlschema.XDerivationControl] = buildXmlschemaXDerivationControlFormat
  def buildXmlschemaXDerivationControlFormat: scalaxb.XMLFormat[xmlschema.XDerivationControl]

  implicit lazy val XmlschemaXSimpleTypeFormat: scalaxb.XMLFormat[xmlschema.XSimpleType] = buildXmlschemaXSimpleTypeFormat
  def buildXmlschemaXSimpleTypeFormat: scalaxb.XMLFormat[xmlschema.XSimpleType]

  implicit lazy val XmlschemaXTopLevelSimpleTypeFormat: scalaxb.XMLFormat[xmlschema.XTopLevelSimpleType] = buildXmlschemaXTopLevelSimpleTypeFormat
  def buildXmlschemaXTopLevelSimpleTypeFormat: scalaxb.XMLFormat[xmlschema.XTopLevelSimpleType]

  implicit lazy val XmlschemaXLocalSimpleTypeFormat: scalaxb.XMLFormat[xmlschema.XLocalSimpleType] = buildXmlschemaXLocalSimpleTypeFormat
  def buildXmlschemaXLocalSimpleTypeFormat: scalaxb.XMLFormat[xmlschema.XLocalSimpleType]

  implicit lazy val XmlschemaXRestrictionFormat: scalaxb.XMLFormat[xmlschema.XRestriction] = buildXmlschemaXRestrictionFormat
  def buildXmlschemaXRestrictionFormat: scalaxb.XMLFormat[xmlschema.XRestriction]

  implicit lazy val XmlschemaXListFormat: scalaxb.XMLFormat[xmlschema.XList] = buildXmlschemaXListFormat
  def buildXmlschemaXListFormat: scalaxb.XMLFormat[xmlschema.XList]

  implicit lazy val XmlschemaXUnionFormat: scalaxb.XMLFormat[xmlschema.XUnion] = buildXmlschemaXUnionFormat
  def buildXmlschemaXUnionFormat: scalaxb.XMLFormat[xmlschema.XUnion]

  implicit lazy val XmlschemaXFacetableFormat: scalaxb.XMLFormat[xmlschema.XFacetable] = buildXmlschemaXFacetableFormat
  def buildXmlschemaXFacetableFormat: scalaxb.XMLFormat[xmlschema.XFacetable]

  implicit lazy val XmlschemaXFacetFormat: scalaxb.XMLFormat[xmlschema.XFacet] = buildXmlschemaXFacetFormat
  def buildXmlschemaXFacetFormat: scalaxb.XMLFormat[xmlschema.XFacet]

  implicit lazy val XmlschemaXNoFixedFacetableFormat: scalaxb.XMLFormat[xmlschema.XNoFixedFacetable] = buildXmlschemaXNoFixedFacetableFormat
  def buildXmlschemaXNoFixedFacetableFormat: scalaxb.XMLFormat[xmlschema.XNoFixedFacetable]

  implicit lazy val XmlschemaXNoFixedFacetFormat: scalaxb.XMLFormat[xmlschema.XNoFixedFacet] = buildXmlschemaXNoFixedFacetFormat
  def buildXmlschemaXNoFixedFacetFormat: scalaxb.XMLFormat[xmlschema.XNoFixedFacet]

  implicit lazy val XmlschemaXNumFacetableFormat: scalaxb.XMLFormat[xmlschema.XNumFacetable] = buildXmlschemaXNumFacetableFormat
  def buildXmlschemaXNumFacetableFormat: scalaxb.XMLFormat[xmlschema.XNumFacetable]

  implicit lazy val XmlschemaXNumFacetFormat: scalaxb.XMLFormat[xmlschema.XNumFacet] = buildXmlschemaXNumFacetFormat
  def buildXmlschemaXNumFacetFormat: scalaxb.XMLFormat[xmlschema.XNumFacet]

  implicit lazy val XmlschemaXTotalDigitsFormat: scalaxb.XMLFormat[xmlschema.XTotalDigits] = buildXmlschemaXTotalDigitsFormat
  def buildXmlschemaXTotalDigitsFormat: scalaxb.XMLFormat[xmlschema.XTotalDigits]

  implicit lazy val XmlschemaXValueFormat: scalaxb.XMLFormat[xmlschema.XValue] = buildXmlschemaXValueFormat
  def buildXmlschemaXValueFormat: scalaxb.XMLFormat[xmlschema.XValue]

  implicit lazy val XmlschemaXWhiteSpaceFormat: scalaxb.XMLFormat[xmlschema.XWhiteSpace] = buildXmlschemaXWhiteSpaceFormat
  def buildXmlschemaXWhiteSpaceFormat: scalaxb.XMLFormat[xmlschema.XWhiteSpace]

  implicit lazy val XmlschemaXPatternFormat: scalaxb.XMLFormat[xmlschema.XPattern] = buildXmlschemaXPatternFormat
  def buildXmlschemaXPatternFormat: scalaxb.XMLFormat[xmlschema.XPattern]

  implicit lazy val XmlschemaXSimpleRestrictionModelSequenceFormat: scalaxb.XMLFormat[xmlschema.XSimpleRestrictionModelSequence] = buildXmlschemaXSimpleRestrictionModelSequenceFormat
  def buildXmlschemaXSimpleRestrictionModelSequenceFormat: scalaxb.XMLFormat[xmlschema.XSimpleRestrictionModelSequence]

  implicit lazy val XmlschemaXAllModelSequenceFormat: scalaxb.XMLFormat[xmlschema.XAllModelSequence] = buildXmlschemaXAllModelSequenceFormat
  def buildXmlschemaXAllModelSequenceFormat: scalaxb.XMLFormat[xmlschema.XAllModelSequence]

  implicit lazy val XmlschemaXComplexTypeModelSequence1Format: scalaxb.XMLFormat[xmlschema.XComplexTypeModelSequence1] = buildXmlschemaXComplexTypeModelSequence1Format
  def buildXmlschemaXComplexTypeModelSequence1Format: scalaxb.XMLFormat[xmlschema.XComplexTypeModelSequence1]

  implicit lazy val XmlschemaXAttrDeclsSequenceFormat: scalaxb.XMLFormat[xmlschema.XAttrDeclsSequence] = buildXmlschemaXAttrDeclsSequenceFormat
  def buildXmlschemaXAttrDeclsSequenceFormat: scalaxb.XMLFormat[xmlschema.XAttrDeclsSequence]

  implicit lazy val XmlschemaXDefRefFormat: scalaxb.AttributeGroupFormat[xmlschema.XDefRef] = buildXmlschemaXDefRefFormat
  def buildXmlschemaXDefRefFormat: scalaxb.AttributeGroupFormat[xmlschema.XDefRef]

  implicit lazy val XmlschemaXOccursFormat: scalaxb.AttributeGroupFormat[xmlschema.XOccurs] = buildXmlschemaXOccursFormat
  def buildXmlschemaXOccursFormat: scalaxb.AttributeGroupFormat[xmlschema.XOccurs]

  
}

object XDefaultXMLProtocol extends XDefaultXMLProtocol with scalaxb.DefaultXMLStandardTypes {
  import scalaxb.Scalaxb._
  val defaultScope = toScope(None -> "http://www.w3.org/2001/XMLSchema",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")  
}

trait XDefaultXMLProtocol extends XXMLProtocol {
  import scalaxb.Scalaxb._

  override def buildXmlschemaXOpenAttrsableFormat = new DefaultXmlschemaXOpenAttrsableFormat {}
  trait DefaultXmlschemaXOpenAttrsableFormat extends scalaxb.XMLFormat[xmlschema.XOpenAttrsable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XOpenAttrsable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("annotated")) => Right(fromXML[xmlschema.XAnnotatedable](node))
          case (targetNamespace, Some("annotation")) => Right(fromXML[xmlschema.XAnnotation](node))
          case (targetNamespace, Some("redefine")) => Right(fromXML[xmlschema.XRedefine](node))
          case (targetNamespace, Some("schema")) => Right(fromXML[xmlschema.XSchema](node))
          case _ => Right(fromXML[xmlschema.XOpenAttrs](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XOpenAttrsable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XAnnotatedable => toXML[xmlschema.XAnnotatedable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAnnotation => toXML[xmlschema.XAnnotation](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XRedefine => toXML[xmlschema.XRedefine](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XSchema => toXML[xmlschema.XSchema](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XOpenAttrs => toXML[xmlschema.XOpenAttrs](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXOpenAttrsFormat = new DefaultXmlschemaXOpenAttrsFormat {}
  trait DefaultXmlschemaXOpenAttrsFormat extends scalaxb.XMLFormat[xmlschema.XOpenAttrs] with scalaxb.CanWriteChildNodes[xmlschema.XOpenAttrs] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XOpenAttrs] = seq match {
      case node: scala.xml.Node => Right(xmlschema.XOpenAttrs(scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: xmlschema.XOpenAttrs, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XOpenAttrs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  override def buildXmlschemaXAnnotatedableFormat = new DefaultXmlschemaXAnnotatedableFormat {}
  trait DefaultXmlschemaXAnnotatedableFormat extends scalaxb.XMLFormat[xmlschema.XAnnotatedable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XAnnotatedable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("attribute")) => Right(fromXML[xmlschema.XAttributable](node))
          case (targetNamespace, Some("complexType")) => Right(fromXML[xmlschema.XComplexType](node))
          case (targetNamespace, Some("restrictionType")) => Right(fromXML[xmlschema.XRestrictionTypable](node))
          case (targetNamespace, Some("extensionType")) => Right(fromXML[xmlschema.XExtensionTypable](node))
          case (targetNamespace, Some("element")) => Right(fromXML[xmlschema.XElement](node))
          case (targetNamespace, Some("group")) => Right(fromXML[xmlschema.XGroup](node))
          case (targetNamespace, Some("wildcard")) => Right(fromXML[xmlschema.XWildcardable](node))
          case (targetNamespace, Some("attributeGroup")) => Right(fromXML[xmlschema.XAttributeGroup](node))
          case (targetNamespace, Some("keybase")) => Right(fromXML[xmlschema.XKeybasable](node))
          case (targetNamespace, Some("simpleType")) => Right(fromXML[xmlschema.XSimpleType](node))
          case (targetNamespace, Some("facet")) => Right(fromXML[xmlschema.XFacetable](node))
          case (targetNamespace, Some("union")) => Right(fromXML[xmlschema.XUnion](node))
          case (targetNamespace, Some("list")) => Right(fromXML[xmlschema.XList](node))
          case (targetNamespace, Some("restriction")) => Right(fromXML[xmlschema.XRestriction](node))
          case (targetNamespace, Some("notation")) => Right(fromXML[xmlschema.XNotation](node))
          case (targetNamespace, Some("field")) => Right(fromXML[xmlschema.XField](node))
          case (targetNamespace, Some("selector")) => Right(fromXML[xmlschema.XSelector](node))
          case (targetNamespace, Some("import")) => Right(fromXML[xmlschema.XImport](node))
          case (targetNamespace, Some("include")) => Right(fromXML[xmlschema.XInclude](node))
          case (targetNamespace, Some("simpleContent")) => Right(fromXML[xmlschema.XSimpleContent](node))
          case (targetNamespace, Some("complexContent")) => Right(fromXML[xmlschema.XComplexContent](node))
          case _ => Right(fromXML[xmlschema.XAnnotated](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XAnnotatedable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XAttributable => toXML[xmlschema.XAttributable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XComplexType => toXML[xmlschema.XComplexType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XRestrictionTypable => toXML[xmlschema.XRestrictionTypable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XExtensionTypable => toXML[xmlschema.XExtensionTypable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XElement => toXML[xmlschema.XElement](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XGroup => toXML[xmlschema.XGroup](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XWildcardable => toXML[xmlschema.XWildcardable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAttributeGroup => toXML[xmlschema.XAttributeGroup](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XKeybasable => toXML[xmlschema.XKeybasable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XSimpleType => toXML[xmlschema.XSimpleType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XFacetable => toXML[xmlschema.XFacetable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XUnion => toXML[xmlschema.XUnion](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XList => toXML[xmlschema.XList](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XRestriction => toXML[xmlschema.XRestriction](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XNotation => toXML[xmlschema.XNotation](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XField => toXML[xmlschema.XField](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XSelector => toXML[xmlschema.XSelector](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XImport => toXML[xmlschema.XImport](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XInclude => toXML[xmlschema.XInclude](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XSimpleContent => toXML[xmlschema.XSimpleContent](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XComplexContent => toXML[xmlschema.XComplexContent](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAnnotated => toXML[xmlschema.XAnnotated](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXAnnotatedFormat = new DefaultXmlschemaXAnnotatedFormat {}
  trait DefaultXmlschemaXAnnotatedFormat extends scalaxb.ElemNameParser[xmlschema.XAnnotated] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("annotated")

    def parser(node: scala.xml.Node): Parser[xmlschema.XAnnotated] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XAnnotated(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAnnotated, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAnnotated, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  def buildXmlschemaXFormChoiceFormat = new DefaultXmlschemaXFormChoiceFormat {}
  trait DefaultXmlschemaXFormChoiceFormat extends scalaxb.XMLFormat[xmlschema.XFormChoice] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XFormChoice] = Right(xmlschema.XFormChoice.fromString(seq.text))
    
    def writes(__obj: xmlschema.XFormChoice, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildXmlschemaXReducedDerivationControlFormat = new DefaultXmlschemaXReducedDerivationControlFormat {}
  trait DefaultXmlschemaXReducedDerivationControlFormat extends scalaxb.XMLFormat[xmlschema.XReducedDerivationControl] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XReducedDerivationControl] = Right(xmlschema.XReducedDerivationControl.fromString(seq.text))
    
    def writes(__obj: xmlschema.XReducedDerivationControl, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildXmlschemaXTypeDerivationControlFormat = new DefaultXmlschemaXTypeDerivationControlFormat {}
  trait DefaultXmlschemaXTypeDerivationControlFormat extends scalaxb.XMLFormat[xmlschema.XTypeDerivationControl] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XTypeDerivationControl] = Right(xmlschema.XTypeDerivationControl.fromString(seq.text))
    
    def writes(__obj: xmlschema.XTypeDerivationControl, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXSchemaFormat = new DefaultXmlschemaXSchemaFormat {}
  trait DefaultXmlschemaXSchemaFormat extends scalaxb.ElemNameParser[xmlschema.XSchema] with XmlschemaXSchemaTopGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XSchema] =
      rep(((scalaxb.ElemName(targetNamespace, "include")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XInclude](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "import")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XImport](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "redefine")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XRedefine](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "annotation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAnnotation](x))))) ~ 
      rep(((parseXSchemaTopGroup) ~ 
      rep(scalaxb.ElemName(targetNamespace, "annotation"))) ^^ 
        { case p1 ~ p2 => xmlschema.XSchemaSequence1(p1,
        p2.toSeq map { fromXML[xmlschema.XAnnotation](_) }) }) ^^
      { case p1 ~ p2 =>
      xmlschema.XSchema(p1.toSeq,
        p2.toSeq,
        (node \ "@targetNamespace").headOption map { fromXML[java.net.URI](_) },
        (node \ "@version").headOption map { fromXML[String](_) },
        (node \ "@finalDefault").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("")) },
        (node \ "@blockDefault").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("")) },
        (node \ "@attributeFormDefault").headOption map { fromXML[xmlschema.XFormChoice](_) } getOrElse { fromXML[xmlschema.XFormChoice](scala.xml.Text("unqualified")) },
        (node \ "@elementFormDefault").headOption map { fromXML[xmlschema.XFormChoice](_) } getOrElse { fromXML[xmlschema.XFormChoice](scala.xml.Text("unqualified")) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "targetNamespace" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "finalDefault" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "blockDefault" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "attributeFormDefault" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "elementFormDefault" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "lang" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XSchema, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.targetNamespace foreach { x => attr = scala.xml.Attribute(null, "targetNamespace", x.toString, attr) }
      __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
      if (__obj.finalDefault.toString != "") attr = scala.xml.Attribute(null, "finalDefault", __obj.finalDefault.toString, attr)
      if (__obj.blockDefault.toString != "") attr = scala.xml.Attribute(null, "blockDefault", __obj.blockDefault.toString, attr)
      if (__obj.attributeFormDefault.toString != "unqualified") attr = scala.xml.Attribute(null, "attributeFormDefault", __obj.attributeFormDefault.toString, attr)
      if (__obj.elementFormDefault.toString != "unqualified") attr = scala.xml.Attribute(null, "elementFormDefault", __obj.elementFormDefault.toString, attr)
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XSchema, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.xschemaoption flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XSchemaOption]](x, x.namespace, x.key, __scope, false) },
        __obj.xschemasequence1 flatMap { toXML[xmlschema.XSchemaSequence1](_, targetNamespace, Some("xschemasequence1"), __scope, false) })

  }

  override def buildXmlschemaXSchemaSequence1Format = new DefaultXmlschemaXSchemaSequence1Format {} 
  trait DefaultXmlschemaXSchemaSequence1Format extends scalaxb.XMLFormat[xmlschema.XSchemaSequence1] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XSchemaSequence1] = Left("don't call me.")
    
    def writes(__obj: xmlschema.XSchemaSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(toXML[scalaxb.DataRecord[Any]](__obj.arg1, targetNamespace, __obj.arg1.key, __scope, false),
        __obj.annotation flatMap { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) })


  }

  def buildXmlschemaXUseFormat = new DefaultXmlschemaXUseFormat {}
  trait DefaultXmlschemaXUseFormat extends scalaxb.XMLFormat[xmlschema.XUse] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XUse] = Right(xmlschema.XUse.fromString(seq.text))
    
    def writes(__obj: xmlschema.XUse, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXAttributableFormat = new DefaultXmlschemaXAttributableFormat {}
  trait DefaultXmlschemaXAttributableFormat extends scalaxb.XMLFormat[xmlschema.XAttributable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XAttributable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("topLevelAttribute")) => Right(fromXML[xmlschema.XTopLevelAttribute](node))
          case _ => Right(fromXML[xmlschema.XAttribute](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XAttributable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XTopLevelAttribute => toXML[xmlschema.XTopLevelAttribute](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAttribute => toXML[xmlschema.XAttribute](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXAttributeFormat = new DefaultXmlschemaXAttributeFormat {}
  trait DefaultXmlschemaXAttributeFormat extends scalaxb.ElemNameParser[xmlschema.XAttribute] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("attribute")

    def parser(node: scala.xml.Node): Parser[xmlschema.XAttribute] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "simpleType")) ^^
      { case p1 ~ p2 =>
      xmlschema.XAttribute(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.headOption map { fromXML[xmlschema.XLocalSimpleType](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@type").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@use").headOption map { fromXML[xmlschema.XUse](_) } getOrElse { fromXML[xmlschema.XUse](scala.xml.Text("optional")) },
        (node \ "@default").headOption map { fromXML[String](_) },
        (node \ "@fixed").headOption map { fromXML[String](_) },
        (node \ "@form").headOption map { fromXML[xmlschema.XFormChoice](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "use" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "default" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "form" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAttribute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      if (__obj.use.toString != "optional") attr = scala.xml.Attribute(null, "use", __obj.use.toString, attr)
      __obj.default foreach { x => attr = scala.xml.Attribute(null, "default", x.toString, attr) }
      __obj.fixed foreach { x => attr = scala.xml.Attribute(null, "fixed", x.toString, attr) }
      __obj.form foreach { x => attr = scala.xml.Attribute(null, "form", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAttribute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.simpleType map { toXML[xmlschema.XLocalSimpleType](_, None, Some("simpleType"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXTopLevelAttributeFormat = new DefaultXmlschemaXTopLevelAttributeFormat {}
  trait DefaultXmlschemaXTopLevelAttributeFormat extends scalaxb.ElemNameParser[xmlschema.XTopLevelAttribute] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("topLevelAttribute")

    def parser(node: scala.xml.Node): Parser[xmlschema.XTopLevelAttribute] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "simpleType")) ^^
      { case p1 ~ p2 =>
      xmlschema.XTopLevelAttribute(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.headOption map { fromXML[xmlschema.XLocalSimpleType](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@type").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@use").headOption map { fromXML[xmlschema.XUse](_) } getOrElse { fromXML[xmlschema.XUse](scala.xml.Text("optional")) },
        (node \ "@default").headOption map { fromXML[String](_) },
        (node \ "@fixed").headOption map { fromXML[String](_) },
        (node \ "@form").headOption map { fromXML[xmlschema.XFormChoice](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "use" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "default" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "form" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XTopLevelAttribute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      if (__obj.use.toString != "optional") attr = scala.xml.Attribute(null, "use", __obj.use.toString, attr)
      __obj.default foreach { x => attr = scala.xml.Attribute(null, "default", x.toString, attr) }
      __obj.fixed foreach { x => attr = scala.xml.Attribute(null, "fixed", x.toString, attr) }
      __obj.form foreach { x => attr = scala.xml.Attribute(null, "form", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XTopLevelAttribute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.simpleType map { toXML[xmlschema.XLocalSimpleType](_, None, Some("simpleType"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXComplexTypeFormat = new DefaultXmlschemaXComplexTypeFormat {}
  trait DefaultXmlschemaXComplexTypeFormat extends scalaxb.XMLFormat[xmlschema.XComplexType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XComplexType] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("topLevelComplexType")) => Right(fromXML[xmlschema.XTopLevelComplexType](node))
          case (targetNamespace, Some("localComplexType")) => Right(fromXML[xmlschema.XLocalComplexType](node))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XComplexType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XTopLevelComplexType => toXML[xmlschema.XTopLevelComplexType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XLocalComplexType => toXML[xmlschema.XLocalComplexType](x, __namespace, __elementLabel, __scope, true)
      case _ => error("Unknown type: " + __obj)
    }
  }

  override def buildXmlschemaXTopLevelComplexTypeFormat = new DefaultXmlschemaXTopLevelComplexTypeFormat {}
  trait DefaultXmlschemaXTopLevelComplexTypeFormat extends scalaxb.ElemNameParser[xmlschema.XTopLevelComplexType] with XmlschemaXComplexTypeModelGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("topLevelComplexType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XTopLevelComplexType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXComplexTypeModelGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XTopLevelComplexType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@mixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@abstract").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@block").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "mixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "abstract" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "block" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XTopLevelComplexType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      if (__obj.mixed.toString != "false") attr = scala.xml.Attribute(null, "mixed", __obj.mixed.toString, attr)
      if (__obj.abstractValue.toString != "false") attr = scala.xml.Attribute(null, "abstract", __obj.abstractValue.toString, attr)
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.block foreach { x => attr = scala.xml.Attribute(null, "block", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XTopLevelComplexType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[scalaxb.DataRecord[xmlschema.XComplexTypeModelOption]](__obj.arg1, targetNamespace, __obj.arg1.key, __scope, false))

  }

  override def buildXmlschemaXLocalComplexTypeFormat = new DefaultXmlschemaXLocalComplexTypeFormat {}
  trait DefaultXmlschemaXLocalComplexTypeFormat extends scalaxb.ElemNameParser[xmlschema.XLocalComplexType] with XmlschemaXComplexTypeModelGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("localComplexType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XLocalComplexType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXComplexTypeModelGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XLocalComplexType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@mixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@abstract").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@block").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "mixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "abstract" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "block" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XLocalComplexType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      if (__obj.mixed.toString != "false") attr = scala.xml.Attribute(null, "mixed", __obj.mixed.toString, attr)
      if (__obj.abstractValue.toString != "false") attr = scala.xml.Attribute(null, "abstract", __obj.abstractValue.toString, attr)
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.block foreach { x => attr = scala.xml.Attribute(null, "block", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XLocalComplexType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[scalaxb.DataRecord[xmlschema.XComplexTypeModelOption]](__obj.arg1, targetNamespace, __obj.arg1.key, __scope, false))

  }

  override def buildXmlschemaXRestrictionTypableFormat = new DefaultXmlschemaXRestrictionTypableFormat {}
  trait DefaultXmlschemaXRestrictionTypableFormat extends scalaxb.XMLFormat[xmlschema.XRestrictionTypable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XRestrictionTypable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("complexRestrictionType")) => Right(fromXML[xmlschema.XComplexRestrictionType](node))
          case (targetNamespace, Some("simpleRestrictionType")) => Right(fromXML[xmlschema.XSimpleRestrictionType](node))
          case _ => Right(fromXML[xmlschema.XRestrictionType](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XRestrictionTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XComplexRestrictionType => toXML[xmlschema.XComplexRestrictionType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XSimpleRestrictionType => toXML[xmlschema.XSimpleRestrictionType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XRestrictionType => toXML[xmlschema.XRestrictionType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXRestrictionTypeFormat = new DefaultXmlschemaXRestrictionTypeFormat {}
  trait DefaultXmlschemaXRestrictionTypeFormat extends scalaxb.ElemNameParser[xmlschema.XRestrictionType] with XmlschemaXTypeDefParticleGroupFormat with XmlschemaXSimpleRestrictionModelGroupFormat with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("restrictionType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XRestrictionType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt((parseXTypeDefParticleGroup(true)) ||| 
      (parseXSimpleRestrictionModelGroup(true))) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XRestrictionType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3,
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[javax.xml.namespace.QName]((node \ "@base")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "base" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XRestrictionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "base", __obj.base.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XRestrictionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xrestrictiontypableoption map { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg2, targetNamespace, Some("arg2"), __scope, false))

  }

  override def buildXmlschemaXComplexRestrictionTypeFormat = new DefaultXmlschemaXComplexRestrictionTypeFormat {}
  trait DefaultXmlschemaXComplexRestrictionTypeFormat extends scalaxb.ElemNameParser[xmlschema.XComplexRestrictionType] with XmlschemaXTypeDefParticleGroupFormat with XmlschemaXSimpleRestrictionModelGroupFormat with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("complexRestrictionType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XComplexRestrictionType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt((parseXTypeDefParticleGroup(true)) ||| 
      (parseXSimpleRestrictionModelGroup(true))) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XComplexRestrictionType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3,
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[javax.xml.namespace.QName]((node \ "@base")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "base" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XComplexRestrictionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "base", __obj.base.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XComplexRestrictionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xrestrictiontypableoption map { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg2, targetNamespace, Some("arg2"), __scope, false))

  }

  override def buildXmlschemaXExtensionTypableFormat = new DefaultXmlschemaXExtensionTypableFormat {}
  trait DefaultXmlschemaXExtensionTypableFormat extends scalaxb.XMLFormat[xmlschema.XExtensionTypable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XExtensionTypable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("simpleExtensionType")) => Right(fromXML[xmlschema.XSimpleExtensionType](node))
          case _ => Right(fromXML[xmlschema.XExtensionType](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XExtensionTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XSimpleExtensionType => toXML[xmlschema.XSimpleExtensionType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XExtensionType => toXML[xmlschema.XExtensionType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXExtensionTypeFormat = new DefaultXmlschemaXExtensionTypeFormat {}
  trait DefaultXmlschemaXExtensionTypeFormat extends scalaxb.ElemNameParser[xmlschema.XExtensionType] with XmlschemaXTypeDefParticleGroupFormat with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("extensionType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XExtensionType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(parseXTypeDefParticleGroup) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XExtensionType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3,
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[javax.xml.namespace.QName]((node \ "@base")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "base" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XExtensionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "base", __obj.base.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XExtensionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 map { x => toXML[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg2, targetNamespace, Some("arg2"), __scope, false))

  }

  override def buildXmlschemaXComplexContentFormat = new DefaultXmlschemaXComplexContentFormat {}
  trait DefaultXmlschemaXComplexContentFormat extends scalaxb.ElemNameParser[xmlschema.XComplexContent] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XComplexContent] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (((scalaxb.ElemName(targetNamespace, "restriction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XComplexRestrictionType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "extension")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExtensionTypable](x))))) ^^
      { case p1 ~ p2 =>
      xmlschema.XComplexContent(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@mixed").headOption map { fromXML[Boolean](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "mixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XComplexContent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.mixed foreach { x => attr = scala.xml.Attribute(null, "mixed", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XComplexContent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[scalaxb.DataRecord[xmlschema.XComplexContentOption]](__obj.xcomplexcontentoption, targetNamespace, __obj.xcomplexcontentoption.key, __scope, false))

  }

  override def buildXmlschemaXSimpleRestrictionTypeFormat = new DefaultXmlschemaXSimpleRestrictionTypeFormat {}
  trait DefaultXmlschemaXSimpleRestrictionTypeFormat extends scalaxb.ElemNameParser[xmlschema.XSimpleRestrictionType] with XmlschemaXTypeDefParticleGroupFormat with XmlschemaXSimpleRestrictionModelGroupFormat with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("simpleRestrictionType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XSimpleRestrictionType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt((parseXTypeDefParticleGroup(true)) ||| 
      (parseXSimpleRestrictionModelGroup(true))) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XSimpleRestrictionType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3,
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[javax.xml.namespace.QName]((node \ "@base")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "base" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XSimpleRestrictionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "base", __obj.base.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XSimpleRestrictionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xrestrictiontypableoption map { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg2, targetNamespace, Some("arg2"), __scope, false))

  }

  override def buildXmlschemaXSimpleExtensionTypeFormat = new DefaultXmlschemaXSimpleExtensionTypeFormat {}
  trait DefaultXmlschemaXSimpleExtensionTypeFormat extends scalaxb.ElemNameParser[xmlschema.XSimpleExtensionType] with XmlschemaXTypeDefParticleGroupFormat with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("simpleExtensionType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XSimpleExtensionType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(parseXTypeDefParticleGroup) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XSimpleExtensionType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3,
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[javax.xml.namespace.QName]((node \ "@base")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "base" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XSimpleExtensionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "base", __obj.base.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XSimpleExtensionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 map { x => toXML[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg2, targetNamespace, Some("arg2"), __scope, false))

  }

  override def buildXmlschemaXSimpleContentFormat = new DefaultXmlschemaXSimpleContentFormat {}
  trait DefaultXmlschemaXSimpleContentFormat extends scalaxb.ElemNameParser[xmlschema.XSimpleContent] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XSimpleContent] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (((scalaxb.ElemName(targetNamespace, "restriction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XSimpleRestrictionType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "extension")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XSimpleExtensionType](x))))) ^^
      { case p1 ~ p2 =>
      xmlschema.XSimpleContent(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XSimpleContent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XSimpleContent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[scalaxb.DataRecord[xmlschema.XSimpleContentOption]](__obj.xsimplecontentoption, targetNamespace, __obj.xsimplecontentoption.key, __scope, false))

  }

  override def buildXmlschemaXElementFormat = new DefaultXmlschemaXElementFormat {}
  trait DefaultXmlschemaXElementFormat extends scalaxb.XMLFormat[xmlschema.XElement] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XElement] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("topLevelElement")) => Right(fromXML[xmlschema.XTopLevelElement](node))
          case (targetNamespace, Some("localElement")) => Right(fromXML[xmlschema.XLocalElementable](node))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XElement, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XTopLevelElement => toXML[xmlschema.XTopLevelElement](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XLocalElementable => toXML[xmlschema.XLocalElementable](x, __namespace, __elementLabel, __scope, true)
      case _ => error("Unknown type: " + __obj)
    }
  }

  override def buildXmlschemaXTopLevelElementFormat = new DefaultXmlschemaXTopLevelElementFormat {}
  trait DefaultXmlschemaXTopLevelElementFormat extends scalaxb.ElemNameParser[xmlschema.XTopLevelElement] with XmlschemaXIdentityConstraintGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("topLevelElement")

    def parser(node: scala.xml.Node): Parser[xmlschema.XTopLevelElement] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(((scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalSimpleType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "complexType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalComplexType](x))))) ~ 
      rep(parseXIdentityConstraintGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XTopLevelElement(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@type").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@substitutionGroup").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        (node \ "@default").headOption map { fromXML[String](_) },
        (node \ "@fixed").headOption map { fromXML[String](_) },
        (node \ "@nillable").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@abstract").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@block").headOption map { fromXML[String](_) },
        (node \ "@form").headOption map { fromXML[xmlschema.XFormChoice](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "substitutionGroup" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "default" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "nillable" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "abstract" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "block" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "form" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XTopLevelElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.substitutionGroup foreach { x => attr = scala.xml.Attribute(null, "substitutionGroup", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.default foreach { x => attr = scala.xml.Attribute(null, "default", x.toString, attr) }
      __obj.fixed foreach { x => attr = scala.xml.Attribute(null, "fixed", x.toString, attr) }
      if (__obj.nillable.toString != "false") attr = scala.xml.Attribute(null, "nillable", __obj.nillable.toString, attr)
      if (__obj.abstractValue.toString != "false") attr = scala.xml.Attribute(null, "abstract", __obj.abstractValue.toString, attr)
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.block foreach { x => attr = scala.xml.Attribute(null, "block", x.toString, attr) }
      __obj.form foreach { x => attr = scala.xml.Attribute(null, "form", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XTopLevelElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xelementoption map { x => toXML[scalaxb.DataRecord[xmlschema.XElementOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.arg2 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXLocalElementableFormat = new DefaultXmlschemaXLocalElementableFormat {}
  trait DefaultXmlschemaXLocalElementableFormat extends scalaxb.XMLFormat[xmlschema.XLocalElementable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XLocalElementable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("narrowMaxMin")) => Right(fromXML[xmlschema.XNarrowMaxMin](node))
          case _ => Right(fromXML[xmlschema.XLocalElement](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XLocalElementable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XNarrowMaxMin => toXML[xmlschema.XNarrowMaxMin](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XLocalElement => toXML[xmlschema.XLocalElement](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXLocalElementFormat = new DefaultXmlschemaXLocalElementFormat {}
  trait DefaultXmlschemaXLocalElementFormat extends scalaxb.ElemNameParser[xmlschema.XLocalElement] with XmlschemaXIdentityConstraintGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("localElement")

    def parser(node: scala.xml.Node): Parser[xmlschema.XLocalElement] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(((scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalSimpleType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "complexType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalComplexType](x))))) ~ 
      rep(parseXIdentityConstraintGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XLocalElement(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@type").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@substitutionGroup").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        (node \ "@default").headOption map { fromXML[String](_) },
        (node \ "@fixed").headOption map { fromXML[String](_) },
        (node \ "@nillable").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@abstract").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@block").headOption map { fromXML[String](_) },
        (node \ "@form").headOption map { fromXML[xmlschema.XFormChoice](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "substitutionGroup" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "default" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "nillable" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "abstract" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "block" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "form" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XLocalElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.substitutionGroup foreach { x => attr = scala.xml.Attribute(null, "substitutionGroup", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.default foreach { x => attr = scala.xml.Attribute(null, "default", x.toString, attr) }
      __obj.fixed foreach { x => attr = scala.xml.Attribute(null, "fixed", x.toString, attr) }
      if (__obj.nillable.toString != "false") attr = scala.xml.Attribute(null, "nillable", __obj.nillable.toString, attr)
      if (__obj.abstractValue.toString != "false") attr = scala.xml.Attribute(null, "abstract", __obj.abstractValue.toString, attr)
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.block foreach { x => attr = scala.xml.Attribute(null, "block", x.toString, attr) }
      __obj.form foreach { x => attr = scala.xml.Attribute(null, "form", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XLocalElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xelementoption map { x => toXML[scalaxb.DataRecord[xmlschema.XElementOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.arg2 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXGroupFormat = new DefaultXmlschemaXGroupFormat {}
  trait DefaultXmlschemaXGroupFormat extends scalaxb.XMLFormat[xmlschema.XGroup] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XGroup] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("realGroup")) => Right(fromXML[xmlschema.XRealGroupable](node))
          case (targetNamespace, Some("explicitGroup")) => Right(fromXML[xmlschema.XExplicitGroupable](node))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XGroup, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XRealGroupable => toXML[xmlschema.XRealGroupable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XExplicitGroupable => toXML[xmlschema.XExplicitGroupable](x, __namespace, __elementLabel, __scope, true)
      case _ => error("Unknown type: " + __obj)
    }
  }

  override def buildXmlschemaXRealGroupableFormat = new DefaultXmlschemaXRealGroupableFormat {}
  trait DefaultXmlschemaXRealGroupableFormat extends scalaxb.XMLFormat[xmlschema.XRealGroupable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XRealGroupable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("namedGroup")) => Right(fromXML[xmlschema.XNamedGroup](node))
          case (targetNamespace, Some("groupRef")) => Right(fromXML[xmlschema.XGroupRef](node))
          case _ => Right(fromXML[xmlschema.XRealGroup](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XRealGroupable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XNamedGroup => toXML[xmlschema.XNamedGroup](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XGroupRef => toXML[xmlschema.XGroupRef](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XRealGroup => toXML[xmlschema.XRealGroup](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXRealGroupFormat = new DefaultXmlschemaXRealGroupFormat {}
  trait DefaultXmlschemaXRealGroupFormat extends scalaxb.ElemNameParser[xmlschema.XRealGroup] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("realGroup")

    def parser(node: scala.xml.Node): Parser[xmlschema.XRealGroup] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XRealGroup(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XRealGroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XRealGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXAllFormat = new DefaultXmlschemaXAllFormat {}
  trait DefaultXmlschemaXAllFormat extends scalaxb.ElemNameParser[xmlschema.XAll] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XAll] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XAll(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAll, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAll, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXNamedGroupFormat = new DefaultXmlschemaXNamedGroupFormat {}
  trait DefaultXmlschemaXNamedGroupFormat extends scalaxb.ElemNameParser[xmlschema.XNamedGroup] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("namedGroup")

    def parser(node: scala.xml.Node): Parser[xmlschema.XNamedGroup] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XNamedGroup(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XNamedGroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XNamedGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXGroupRefFormat = new DefaultXmlschemaXGroupRefFormat {}
  trait DefaultXmlschemaXGroupRefFormat extends scalaxb.ElemNameParser[xmlschema.XGroupRef] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("groupRef")

    def parser(node: scala.xml.Node): Parser[xmlschema.XGroupRef] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XGroupRef(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XGroupRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XGroupRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXExplicitGroupableFormat = new DefaultXmlschemaXExplicitGroupableFormat {}
  trait DefaultXmlschemaXExplicitGroupableFormat extends scalaxb.XMLFormat[xmlschema.XExplicitGroupable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XExplicitGroupable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("simpleExplicitGroup")) => Right(fromXML[xmlschema.XSimpleExplicitGroup](node))
          case (targetNamespace, Some("all")) => Right(fromXML[xmlschema.XAllable](node))
          case _ => Right(fromXML[xmlschema.XExplicitGroup](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XExplicitGroupable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XSimpleExplicitGroup => toXML[xmlschema.XSimpleExplicitGroup](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAllable => toXML[xmlschema.XAllable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XExplicitGroup => toXML[xmlschema.XExplicitGroup](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXExplicitGroupFormat = new DefaultXmlschemaXExplicitGroupFormat {}
  trait DefaultXmlschemaXExplicitGroupFormat extends scalaxb.ElemNameParser[xmlschema.XExplicitGroup] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("explicitGroup")

    def parser(node: scala.xml.Node): Parser[xmlschema.XExplicitGroup] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XExplicitGroup(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XExplicitGroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XExplicitGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXSimpleExplicitGroupFormat = new DefaultXmlschemaXSimpleExplicitGroupFormat {}
  trait DefaultXmlschemaXSimpleExplicitGroupFormat extends scalaxb.ElemNameParser[xmlschema.XSimpleExplicitGroup] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("simpleExplicitGroup")

    def parser(node: scala.xml.Node): Parser[xmlschema.XSimpleExplicitGroup] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XSimpleExplicitGroup(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XSimpleExplicitGroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XSimpleExplicitGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  def buildXmlschemaXMinOccursFormat = new DefaultXmlschemaXMinOccursFormat {}
  trait DefaultXmlschemaXMinOccursFormat extends scalaxb.XMLFormat[xmlschema.XMinOccurs] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XMinOccurs] = Right(xmlschema.XMinOccurs.fromString(seq.text))
    
    def writes(__obj: xmlschema.XMinOccurs, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildXmlschemaXMaxOccursFormat = new DefaultXmlschemaXMaxOccursFormat {}
  trait DefaultXmlschemaXMaxOccursFormat extends scalaxb.XMLFormat[xmlschema.XMaxOccurs] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XMaxOccurs] = Right(xmlschema.XMaxOccurs.fromString(seq.text))
    
    def writes(__obj: xmlschema.XMaxOccurs, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXNarrowMaxMinFormat = new DefaultXmlschemaXNarrowMaxMinFormat {}
  trait DefaultXmlschemaXNarrowMaxMinFormat extends scalaxb.ElemNameParser[xmlschema.XNarrowMaxMin] with XmlschemaXIdentityConstraintGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("narrowMaxMin")

    def parser(node: scala.xml.Node): Parser[xmlschema.XNarrowMaxMin] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(((scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalSimpleType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "complexType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalComplexType](x))))) ~ 
      rep(parseXIdentityConstraintGroup) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XNarrowMaxMin(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        p3.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@type").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@substitutionGroup").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        (node \ "@default").headOption map { fromXML[String](_) },
        (node \ "@fixed").headOption map { fromXML[String](_) },
        (node \ "@nillable").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@abstract").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@block").headOption map { fromXML[String](_) },
        (node \ "@form").headOption map { fromXML[xmlschema.XFormChoice](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "type" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "substitutionGroup" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "default" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "nillable" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "abstract" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "block" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "form" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XNarrowMaxMin, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.substitutionGroup foreach { x => attr = scala.xml.Attribute(null, "substitutionGroup", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.default foreach { x => attr = scala.xml.Attribute(null, "default", x.toString, attr) }
      __obj.fixed foreach { x => attr = scala.xml.Attribute(null, "fixed", x.toString, attr) }
      if (__obj.nillable.toString != "false") attr = scala.xml.Attribute(null, "nillable", __obj.nillable.toString, attr)
      if (__obj.abstractValue.toString != "false") attr = scala.xml.Attribute(null, "abstract", __obj.abstractValue.toString, attr)
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.block foreach { x => attr = scala.xml.Attribute(null, "block", x.toString, attr) }
      __obj.form foreach { x => attr = scala.xml.Attribute(null, "form", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XNarrowMaxMin, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xelementoption map { x => toXML[scalaxb.DataRecord[xmlschema.XElementOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.arg2 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]](x, x.namespace, x.key, __scope, false) })

  }

  def buildXmlschemaXMinOccursTypeFormat = new DefaultXmlschemaXMinOccursTypeFormat {}
  trait DefaultXmlschemaXMinOccursTypeFormat extends scalaxb.XMLFormat[xmlschema.XMinOccursType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XMinOccursType] = Right(xmlschema.XMinOccursType.fromString(seq.text))
    
    def writes(__obj: xmlschema.XMinOccursType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildXmlschemaXMaxOccursTypeFormat = new DefaultXmlschemaXMaxOccursTypeFormat {}
  trait DefaultXmlschemaXMaxOccursTypeFormat extends scalaxb.XMLFormat[xmlschema.XMaxOccursType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XMaxOccursType] = Right(xmlschema.XMaxOccursType.fromString(seq.text))
    
    def writes(__obj: xmlschema.XMaxOccursType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXAllableFormat = new DefaultXmlschemaXAllableFormat {}
  trait DefaultXmlschemaXAllableFormat extends scalaxb.XMLFormat[xmlschema.XAllable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XAllable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("all")) => Right(fromXML[xmlschema.XAll](node))
          case _ => Right(fromXML[xmlschema.XAllType](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XAllable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XAll => toXML[xmlschema.XAll](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAllType => toXML[xmlschema.XAllType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXAllTypeFormat = new DefaultXmlschemaXAllTypeFormat {}
  trait DefaultXmlschemaXAllTypeFormat extends scalaxb.ElemNameParser[xmlschema.XAllType] with XmlschemaXParticleGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("all")

    def parser(node: scala.xml.Node): Parser[xmlschema.XAllType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(parseXParticleGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XAllType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAllType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAllType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.arg1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XParticleOption]](x, x.namespace, x.key, __scope, false) })

  }

  def buildXmlschemaXProcessContentsFormat = new DefaultXmlschemaXProcessContentsFormat {}
  trait DefaultXmlschemaXProcessContentsFormat extends scalaxb.XMLFormat[xmlschema.XProcessContents] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XProcessContents] = Right(xmlschema.XProcessContents.fromString(seq.text))
    
    def writes(__obj: xmlschema.XProcessContents, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXWildcardableFormat = new DefaultXmlschemaXWildcardableFormat {}
  trait DefaultXmlschemaXWildcardableFormat extends scalaxb.XMLFormat[xmlschema.XWildcardable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XWildcardable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("any")) => Right(fromXML[xmlschema.XAny](node))
          case _ => Right(fromXML[xmlschema.XWildcard](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XWildcardable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XAny => toXML[xmlschema.XAny](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XWildcard => toXML[xmlschema.XWildcard](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXWildcardFormat = new DefaultXmlschemaXWildcardFormat {}
  trait DefaultXmlschemaXWildcardFormat extends scalaxb.ElemNameParser[xmlschema.XWildcard] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("wildcard")

    def parser(node: scala.xml.Node): Parser[xmlschema.XWildcard] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XWildcard(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@namespace").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("##any")) },
        (node \ "@processContents").headOption map { fromXML[xmlschema.XProcessContents](_) } getOrElse { fromXML[xmlschema.XProcessContents](scala.xml.Text("strict")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "namespace" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "processContents" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XWildcard, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      if (__obj.namespace.toString != "##any") attr = scala.xml.Attribute(null, "namespace", __obj.namespace.toString, attr)
      if (__obj.processContents.toString != "strict") attr = scala.xml.Attribute(null, "processContents", __obj.processContents.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XWildcard, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXAnyFormat = new DefaultXmlschemaXAnyFormat {}
  trait DefaultXmlschemaXAnyFormat extends scalaxb.ElemNameParser[xmlschema.XAny] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XAny] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XAny(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@namespace").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("##any")) },
        (node \ "@processContents").headOption map { fromXML[xmlschema.XProcessContents](_) } getOrElse { fromXML[xmlschema.XProcessContents](scala.xml.Text("strict")) },
        (node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
        (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "namespace" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "processContents" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "minOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "maxOccurs" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAny, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      if (__obj.namespace.toString != "##any") attr = scala.xml.Attribute(null, "namespace", __obj.namespace.toString, attr)
      if (__obj.processContents.toString != "strict") attr = scala.xml.Attribute(null, "processContents", __obj.processContents.toString, attr)
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
      if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAny, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXAttributeGroupFormat = new DefaultXmlschemaXAttributeGroupFormat {}
  trait DefaultXmlschemaXAttributeGroupFormat extends scalaxb.XMLFormat[xmlschema.XAttributeGroup] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XAttributeGroup] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("namedAttributeGroup")) => Right(fromXML[xmlschema.XNamedAttributeGroup](node))
          case (targetNamespace, Some("attributeGroupRef")) => Right(fromXML[xmlschema.XAttributeGroupRef](node))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XAttributeGroup, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XNamedAttributeGroup => toXML[xmlschema.XNamedAttributeGroup](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XAttributeGroupRef => toXML[xmlschema.XAttributeGroupRef](x, __namespace, __elementLabel, __scope, true)
      case _ => error("Unknown type: " + __obj)
    }
  }

  override def buildXmlschemaXNamedAttributeGroupFormat = new DefaultXmlschemaXNamedAttributeGroupFormat {}
  trait DefaultXmlschemaXNamedAttributeGroupFormat extends scalaxb.ElemNameParser[xmlschema.XNamedAttributeGroup] with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("namedAttributeGroup")

    def parser(node: scala.xml.Node): Parser[xmlschema.XNamedAttributeGroup] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XNamedAttributeGroup(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XNamedAttributeGroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XNamedAttributeGroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg1, targetNamespace, Some("arg1"), __scope, false))

  }

  override def buildXmlschemaXAttributeGroupRefFormat = new DefaultXmlschemaXAttributeGroupRefFormat {}
  trait DefaultXmlschemaXAttributeGroupRefFormat extends scalaxb.ElemNameParser[xmlschema.XAttributeGroupRef] with XmlschemaXAttrDeclsGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("attributeGroupRef")

    def parser(node: scala.xml.Node): Parser[xmlschema.XAttributeGroupRef] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXAttrDeclsGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XAttributeGroupRef(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "ref" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAttributeGroupRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAttributeGroupRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg1, targetNamespace, Some("arg1"), __scope, false))

  }

  override def buildXmlschemaXIncludeFormat = new DefaultXmlschemaXIncludeFormat {}
  trait DefaultXmlschemaXIncludeFormat extends scalaxb.ElemNameParser[xmlschema.XInclude] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XInclude] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XInclude(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[java.net.URI]((node \ "@schemaLocation")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "schemaLocation" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XInclude, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "schemaLocation", __obj.schemaLocation.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XInclude, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXRedefineFormat = new DefaultXmlschemaXRedefineFormat {}
  trait DefaultXmlschemaXRedefineFormat extends scalaxb.ElemNameParser[xmlschema.XRedefine] with XmlschemaXRedefinableGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XRedefine] =
      rep(((scalaxb.ElemName(targetNamespace, "annotation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAnnotation](x)))) ||| 
      (parseXRedefinableGroup(true))) ^^
      { case p1 =>
      xmlschema.XRedefine(p1.toSeq,
        fromXML[java.net.URI]((node \ "@schemaLocation")),
        (node \ "@id").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "schemaLocation" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XRedefine, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "schemaLocation", __obj.schemaLocation.toString, attr)
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XRedefine, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xredefineoption flatMap { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXImportFormat = new DefaultXmlschemaXImportFormat {}
  trait DefaultXmlschemaXImportFormat extends scalaxb.ElemNameParser[xmlschema.XImport] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XImport] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XImport(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@namespace").headOption map { fromXML[java.net.URI](_) },
        (node \ "@schemaLocation").headOption map { fromXML[java.net.URI](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "namespace" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "schemaLocation" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XImport, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.namespace foreach { x => attr = scala.xml.Attribute(null, "namespace", x.toString, attr) }
      __obj.schemaLocation foreach { x => attr = scala.xml.Attribute(null, "schemaLocation", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XImport, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXSelectorFormat = new DefaultXmlschemaXSelectorFormat {}
  trait DefaultXmlschemaXSelectorFormat extends scalaxb.ElemNameParser[xmlschema.XSelector] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XSelector] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XSelector(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@xpath")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "xpath" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XSelector, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "xpath", __obj.xpath.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XSelector, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXFieldFormat = new DefaultXmlschemaXFieldFormat {}
  trait DefaultXmlschemaXFieldFormat extends scalaxb.ElemNameParser[xmlschema.XField] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XField] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XField(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@xpath")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "xpath" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XField, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "xpath", __obj.xpath.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XField, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXKeybasableFormat = new DefaultXmlschemaXKeybasableFormat {}
  trait DefaultXmlschemaXKeybasableFormat extends scalaxb.XMLFormat[xmlschema.XKeybasable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XKeybasable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("keyref")) => Right(fromXML[xmlschema.XKeyref](node))
          case _ => Right(fromXML[xmlschema.XKeybase](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XKeybasable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XKeyref => toXML[xmlschema.XKeyref](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XKeybase => toXML[xmlschema.XKeybase](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXKeybaseFormat = new DefaultXmlschemaXKeybaseFormat {}
  trait DefaultXmlschemaXKeybaseFormat extends scalaxb.ElemNameParser[xmlschema.XKeybase] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("keybase")

    def parser(node: scala.xml.Node): Parser[xmlschema.XKeybase] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (scalaxb.ElemName(targetNamespace, "selector")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "field")) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XKeybase(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        fromXML[xmlschema.XSelector](p2),
        p3.toSeq map { fromXML[xmlschema.XField](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@name")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XKeybase, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XKeybase, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XSelector](__obj.selector, targetNamespace, Some("selector"), __scope, false),
        __obj.field flatMap { toXML[xmlschema.XField](_, targetNamespace, Some("field"), __scope, false) })

  }

  override def buildXmlschemaXKeyrefFormat = new DefaultXmlschemaXKeyrefFormat {}
  trait DefaultXmlschemaXKeyrefFormat extends scalaxb.ElemNameParser[xmlschema.XKeyref] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XKeyref] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (scalaxb.ElemName(targetNamespace, "selector")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "field")) ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XKeyref(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        fromXML[xmlschema.XSelector](p2),
        p3.toSeq map { fromXML[xmlschema.XField](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@name")),
        fromXML[javax.xml.namespace.QName]((node \ "@refer")),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "refer" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XKeyref, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      attr = scala.xml.Attribute(null, "refer", __obj.refer.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XKeyref, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XSelector](__obj.selector, targetNamespace, Some("selector"), __scope, false),
        __obj.field flatMap { toXML[xmlschema.XField](_, targetNamespace, Some("field"), __scope, false) })

  }

  override def buildXmlschemaXNotationFormat = new DefaultXmlschemaXNotationFormat {}
  trait DefaultXmlschemaXNotationFormat extends scalaxb.ElemNameParser[xmlschema.XNotation] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XNotation] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XNotation(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@name")),
        (node \ "@public").headOption map { fromXML[String](_) },
        (node \ "@system").headOption map { fromXML[java.net.URI](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "public" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "system" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XNotation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      __obj.public foreach { x => attr = scala.xml.Attribute(null, "public", x.toString, attr) }
      __obj.system foreach { x => attr = scala.xml.Attribute(null, "system", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XNotation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXAppinfoFormat = new DefaultXmlschemaXAppinfoFormat {}
  trait DefaultXmlschemaXAppinfoFormat extends scalaxb.ElemNameParser[xmlschema.XAppinfo] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node): Parser[xmlschema.XAppinfo] =
      optTextRecord ~ 
      rep(((any ^^ (fromXML[scalaxb.DataRecord[Any]](_))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XAppinfo(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        (node \ "@source").headOption map { fromXML[java.net.URI](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "source" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAppinfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.source foreach { x => attr = scala.xml.Attribute(null, "source", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAppinfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  override def buildXmlschemaXDocumentationFormat = new DefaultXmlschemaXDocumentationFormat {}
  trait DefaultXmlschemaXDocumentationFormat extends scalaxb.ElemNameParser[xmlschema.XDocumentation] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node): Parser[xmlschema.XDocumentation] =
      optTextRecord ~ 
      rep(((any ^^ (fromXML[scalaxb.DataRecord[Any]](_))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XDocumentation(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        (node \ "@source").headOption map { fromXML[java.net.URI](_) },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "source" => Nil
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "lang" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XDocumentation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.source foreach { x => attr = scala.xml.Attribute(null, "source", x.toString, attr) }
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XDocumentation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  override def buildXmlschemaXAnnotationFormat = new DefaultXmlschemaXAnnotationFormat {}
  trait DefaultXmlschemaXAnnotationFormat extends scalaxb.ElemNameParser[xmlschema.XAnnotation] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XAnnotation] =
      rep(((scalaxb.ElemName(targetNamespace, "appinfo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAppinfo](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "documentation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XDocumentation](x))))) ^^
      { case p1 =>
      xmlschema.XAnnotation(p1.toSeq,
        (node \ "@id").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAnnotation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAnnotation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.xannotationoption flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XAnnotationOption]](x, x.namespace, x.key, __scope, false) })

  }

  override def buildXmlschemaXAnyTypeFormat = new DefaultXmlschemaXAnyTypeFormat {}
  trait DefaultXmlschemaXAnyTypeFormat extends scalaxb.ElemNameParser[xmlschema.XAnyType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("anyType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node): Parser[xmlschema.XAnyType] =
      optTextRecord ~ 
      rep(((any ^^ (fromXML[scalaxb.DataRecord[Any]](_))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      xmlschema.XAnyType(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XAnyType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XAnyType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  def buildXmlschemaXDerivationControlFormat = new DefaultXmlschemaXDerivationControlFormat {}
  trait DefaultXmlschemaXDerivationControlFormat extends scalaxb.XMLFormat[xmlschema.XDerivationControl] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XDerivationControl] = Right(xmlschema.XDerivationControl.fromString(seq.text))
    
    def writes(__obj: xmlschema.XDerivationControl, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXSimpleTypeFormat = new DefaultXmlschemaXSimpleTypeFormat {}
  trait DefaultXmlschemaXSimpleTypeFormat extends scalaxb.XMLFormat[xmlschema.XSimpleType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XSimpleType] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("topLevelSimpleType")) => Right(fromXML[xmlschema.XTopLevelSimpleType](node))
          case (targetNamespace, Some("localSimpleType")) => Right(fromXML[xmlschema.XLocalSimpleType](node))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XSimpleType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XTopLevelSimpleType => toXML[xmlschema.XTopLevelSimpleType](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XLocalSimpleType => toXML[xmlschema.XLocalSimpleType](x, __namespace, __elementLabel, __scope, true)
      case _ => error("Unknown type: " + __obj)
    }
  }

  override def buildXmlschemaXTopLevelSimpleTypeFormat = new DefaultXmlschemaXTopLevelSimpleTypeFormat {}
  trait DefaultXmlschemaXTopLevelSimpleTypeFormat extends scalaxb.ElemNameParser[xmlschema.XTopLevelSimpleType] with XmlschemaXSimpleDerivationGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("topLevelSimpleType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XTopLevelSimpleType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXSimpleDerivationGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XTopLevelSimpleType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XTopLevelSimpleType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XTopLevelSimpleType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[scalaxb.DataRecord[xmlschema.XSimpleDerivationOption]](__obj.arg1, targetNamespace, __obj.arg1.key, __scope, false))

  }

  override def buildXmlschemaXLocalSimpleTypeFormat = new DefaultXmlschemaXLocalSimpleTypeFormat {}
  trait DefaultXmlschemaXLocalSimpleTypeFormat extends scalaxb.ElemNameParser[xmlschema.XLocalSimpleType] with XmlschemaXSimpleDerivationGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("localSimpleType")

    def parser(node: scala.xml.Node): Parser[xmlschema.XLocalSimpleType] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXSimpleDerivationGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XLocalSimpleType(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@final").headOption map { fromXML[String](_) },
        (node \ "@name").headOption map { fromXML[String](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "final" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XLocalSimpleType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.finalValue foreach { x => attr = scala.xml.Attribute(null, "final", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XLocalSimpleType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[scalaxb.DataRecord[xmlschema.XSimpleDerivationOption]](__obj.arg1, targetNamespace, __obj.arg1.key, __scope, false))

  }

  override def buildXmlschemaXRestrictionFormat = new DefaultXmlschemaXRestrictionFormat {}
  trait DefaultXmlschemaXRestrictionFormat extends scalaxb.ElemNameParser[xmlschema.XRestriction] with XmlschemaXSimpleRestrictionModelGroupFormat {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XRestriction] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      (parseXSimpleRestrictionModelGroup) ^^
      { case p1 ~ p2 =>
      xmlschema.XRestriction(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2,
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@base").headOption map { fromXML[javax.xml.namespace.QName](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "base" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XRestriction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.base foreach { x => attr = scala.xml.Attribute(null, "base", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XRestriction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XSimpleRestrictionModelSequence](__obj.arg1, targetNamespace, Some("arg1"), __scope, false))

  }

  override def buildXmlschemaXListFormat = new DefaultXmlschemaXListFormat {}
  trait DefaultXmlschemaXListFormat extends scalaxb.ElemNameParser[xmlschema.XList] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XList] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      opt(scalaxb.ElemName(targetNamespace, "simpleType")) ^^
      { case p1 ~ p2 =>
      xmlschema.XList(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.headOption map { fromXML[xmlschema.XLocalSimpleType](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@itemType").headOption map { fromXML[javax.xml.namespace.QName](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "itemType" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XList, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.itemType foreach { x => attr = scala.xml.Attribute(null, "itemType", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XList, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.simpleType map { toXML[xmlschema.XLocalSimpleType](_, None, Some("simpleType"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXUnionFormat = new DefaultXmlschemaXUnionFormat {}
  trait DefaultXmlschemaXUnionFormat extends scalaxb.ElemNameParser[xmlschema.XUnion] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XUnion] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(scalaxb.ElemName(targetNamespace, "simpleType")) ^^
      { case p1 ~ p2 =>
      xmlschema.XUnion(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq map { fromXML[xmlschema.XLocalSimpleType](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        (node \ "@memberTypes").headOption map { fromXML[Seq[javax.xml.namespace.QName]](_) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "memberTypes" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XUnion, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.memberTypes foreach { x => attr = scala.xml.Attribute(null, "memberTypes", x.map(x => x.toString).mkString(" "), attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XUnion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.simpleType flatMap { toXML[xmlschema.XLocalSimpleType](_, None, Some("simpleType"), __scope, false) })

  }

  override def buildXmlschemaXFacetableFormat = new DefaultXmlschemaXFacetableFormat {}
  trait DefaultXmlschemaXFacetableFormat extends scalaxb.XMLFormat[xmlschema.XFacetable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XFacetable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("noFixedFacet")) => Right(fromXML[xmlschema.XNoFixedFacetable](node))
          case (targetNamespace, Some("numFacet")) => Right(fromXML[xmlschema.XNumFacetable](node))
          case (targetNamespace, Some("whiteSpace")) => Right(fromXML[xmlschema.XWhiteSpace](node))
          case _ => Right(fromXML[xmlschema.XFacet](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XFacetable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XNoFixedFacetable => toXML[xmlschema.XNoFixedFacetable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XNumFacetable => toXML[xmlschema.XNumFacetable](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XWhiteSpace => toXML[xmlschema.XWhiteSpace](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XFacet => toXML[xmlschema.XFacet](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXFacetFormat = new DefaultXmlschemaXFacetFormat {}
  trait DefaultXmlschemaXFacetFormat extends scalaxb.ElemNameParser[xmlschema.XFacet] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("facet")

    def parser(node: scala.xml.Node): Parser[xmlschema.XFacet] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XFacet(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@value")),
        (node \ "@fixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "value" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XFacet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      if (__obj.fixed.toString != "false") attr = scala.xml.Attribute(null, "fixed", __obj.fixed.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XFacet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXNoFixedFacetableFormat = new DefaultXmlschemaXNoFixedFacetableFormat {}
  trait DefaultXmlschemaXNoFixedFacetableFormat extends scalaxb.XMLFormat[xmlschema.XNoFixedFacetable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XNoFixedFacetable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("pattern")) => Right(fromXML[xmlschema.XPattern](node))
          case _ => Right(fromXML[xmlschema.XNoFixedFacet](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XNoFixedFacetable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XPattern => toXML[xmlschema.XPattern](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XNoFixedFacet => toXML[xmlschema.XNoFixedFacet](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXNoFixedFacetFormat = new DefaultXmlschemaXNoFixedFacetFormat {}
  trait DefaultXmlschemaXNoFixedFacetFormat extends scalaxb.ElemNameParser[xmlschema.XNoFixedFacet] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("noFixedFacet")

    def parser(node: scala.xml.Node): Parser[xmlschema.XNoFixedFacet] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XNoFixedFacet(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@value")),
        (node \ "@fixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "value" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XNoFixedFacet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      if (__obj.fixed.toString != "false") attr = scala.xml.Attribute(null, "fixed", __obj.fixed.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XNoFixedFacet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXNumFacetableFormat = new DefaultXmlschemaXNumFacetableFormat {}
  trait DefaultXmlschemaXNumFacetableFormat extends scalaxb.XMLFormat[xmlschema.XNumFacetable] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XNumFacetable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (targetNamespace, Some("totalDigits")) => Right(fromXML[xmlschema.XTotalDigits](node))
          case _ => Right(fromXML[xmlschema.XNumFacet](node))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: xmlschema.XNumFacetable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: xmlschema.XTotalDigits => toXML[xmlschema.XTotalDigits](x, __namespace, __elementLabel, __scope, true)
      case x: xmlschema.XNumFacet => toXML[xmlschema.XNumFacet](x, __namespace, __elementLabel, __scope, false)
    }
  }

  override def buildXmlschemaXNumFacetFormat = new DefaultXmlschemaXNumFacetFormat {}
  trait DefaultXmlschemaXNumFacetFormat extends scalaxb.ElemNameParser[xmlschema.XNumFacet] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    override def typeName: Option[String] = Some("numFacet")

    def parser(node: scala.xml.Node): Parser[xmlschema.XNumFacet] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XNumFacet(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@value")),
        (node \ "@fixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "value" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XNumFacet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      if (__obj.fixed.toString != "false") attr = scala.xml.Attribute(null, "fixed", __obj.fixed.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XNumFacet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXTotalDigitsFormat = new DefaultXmlschemaXTotalDigitsFormat {}
  trait DefaultXmlschemaXTotalDigitsFormat extends scalaxb.ElemNameParser[xmlschema.XTotalDigits] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XTotalDigits] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XTotalDigits(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@value")),
        (node \ "@fixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "value" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XTotalDigits, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      if (__obj.fixed.toString != "false") attr = scala.xml.Attribute(null, "fixed", __obj.fixed.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XTotalDigits, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  def buildXmlschemaXValueFormat = new DefaultXmlschemaXValueFormat {}
  trait DefaultXmlschemaXValueFormat extends scalaxb.XMLFormat[xmlschema.XValue] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XValue] = Right(xmlschema.XValue.fromString(seq.text))
    
    def writes(__obj: xmlschema.XValue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  override def buildXmlschemaXWhiteSpaceFormat = new DefaultXmlschemaXWhiteSpaceFormat {}
  trait DefaultXmlschemaXWhiteSpaceFormat extends scalaxb.ElemNameParser[xmlschema.XWhiteSpace] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XWhiteSpace] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XWhiteSpace(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@value")),
        (node \ "@fixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "value" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XWhiteSpace, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      if (__obj.fixed.toString != "false") attr = scala.xml.Attribute(null, "fixed", __obj.fixed.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XWhiteSpace, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }

  override def buildXmlschemaXPatternFormat = new DefaultXmlschemaXPatternFormat {}
  trait DefaultXmlschemaXPatternFormat extends scalaxb.ElemNameParser[xmlschema.XPattern] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parser(node: scala.xml.Node): Parser[xmlschema.XPattern] =
      opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^
      { case p1 =>
      xmlschema.XPattern(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        (node \ "@id").headOption map { fromXML[String](_) },
        fromXML[String]((node \ "@value")),
        (node \ "@fixed").headOption map { fromXML[Boolean](_) } getOrElse { fromXML[Boolean](scala.xml.Text("false")) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "value" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "fixed" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) }
    
    override def writesAttribute(__obj: xmlschema.XPattern, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr = scala.xml.Attribute(null, "value", __obj.value.toString, attr)
      if (__obj.fixed.toString != "false") attr = scala.xml.Attribute(null, "fixed", __obj.fixed.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmlschema.XPattern, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil})

  }


  trait XmlschemaXSimpleRestrictionModelGroupFormat extends XmlschemaXFacetsGroupFormat {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXSimpleRestrictionModelGroup: Parser[xmlschema.XSimpleRestrictionModelSequence] =
      ((opt(scalaxb.ElemName(targetNamespace, "simpleType")) ~ 
      rep(parseXFacetsGroup)) ^^ 
        { case p1 ~ p2 => xmlschema.XSimpleRestrictionModelSequence(p1.headOption map { fromXML[xmlschema.XLocalSimpleType](_) },
        p2.toSeq) })
  
    def parseXSimpleRestrictionModelGroup(wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(targetNamespace, "simpleType")) ~ 
      rep(parseXFacetsGroup)) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(xmlschema.XSimpleRestrictionModelSequence(p1.headOption map { fromXML[xmlschema.XLocalSimpleType](_) },
        p2.toSeq)) })
    
    def parsemixedXSimpleRestrictionModelGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalSimpleType](x)) })) ~ 
      optTextRecord ~ 
      rep(parsemixedXFacetsGroup) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.toList,
        p2.toList,
        p3.flatten,
        p4.toList) })
  }

  override def buildXmlschemaXSimpleRestrictionModelSequenceFormat = new DefaultXmlschemaXSimpleRestrictionModelSequenceFormat {} 
  trait DefaultXmlschemaXSimpleRestrictionModelSequenceFormat extends scalaxb.XMLFormat[xmlschema.XSimpleRestrictionModelSequence] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XSimpleRestrictionModelSequence] = Left("don't call me.")
    
    def writes(__obj: xmlschema.XSimpleRestrictionModelSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.simpleType map { toXML[xmlschema.XLocalSimpleType](_, None, Some("simpleType"), __scope, false) } getOrElse {Nil},
        __obj.arg2 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XFacetsOption]](x, x.namespace, x.key, __scope, false) })


  }


/**  
       We should use a substitution group for facets, but
       that's ruled out because it would allow users to
       add their own, which we're not ready for yet.
    
*/
  trait XmlschemaXFacetsGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXFacetsGroup: Parser[scalaxb.DataRecord[xmlschema.XFacetsOption]] =
      (((scalaxb.ElemName(targetNamespace, "minExclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "minInclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "maxExclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "maxInclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "totalDigits")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTotalDigits](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "fractionDigits")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "length")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "minLength")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "maxLength")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "enumeration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNoFixedFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "whiteSpace")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XWhiteSpace](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "pattern")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XPattern](x)))))
  
    def parseXFacetsGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XFacetsOption]] =
      (((scalaxb.ElemName(targetNamespace, "minExclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "minInclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "maxExclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "maxInclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "totalDigits")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTotalDigits](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "fractionDigits")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "length")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "minLength")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "maxLength")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "enumeration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNoFixedFacetable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "whiteSpace")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XWhiteSpace](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "pattern")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XPattern](x)))))
    
    def parsemixedXFacetsGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "minExclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "minInclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "maxExclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "maxInclusive")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "totalDigits")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTotalDigits](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "fractionDigits")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "length")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "minLength")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "maxLength")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNumFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "enumeration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNoFixedFacetable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "whiteSpace")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XWhiteSpace](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "pattern")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XPattern](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


  trait XmlschemaXSimpleDerivationGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXSimpleDerivationGroup: Parser[scalaxb.DataRecord[xmlschema.XSimpleDerivationOption]] =
      (((scalaxb.ElemName(targetNamespace, "restriction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XRestriction](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XList](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "union")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XUnion](x)))))
  
    def parseXSimpleDerivationGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XSimpleDerivationOption]] =
      (((scalaxb.ElemName(targetNamespace, "restriction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XRestriction](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XList](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "union")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XUnion](x)))))
    
    def parsemixedXSimpleDerivationGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "restriction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XRestriction](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XList](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "union")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XUnion](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** The three kinds of identity constraints, all with
                     type of or derived from 'keybase'.
   
*/
  trait XmlschemaXIdentityConstraintGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXIdentityConstraintGroup: Parser[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]] =
      (((scalaxb.ElemName(targetNamespace, "unique")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeybasable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "key")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeybasable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "keyref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeyref](x)))))
  
    def parseXIdentityConstraintGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XIdentityConstraintOption]] =
      (((scalaxb.ElemName(targetNamespace, "unique")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeybasable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "key")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeybasable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "keyref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeyref](x)))))
    
    def parsemixedXIdentityConstraintGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "unique")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeybasable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "key")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeybasable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "keyref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XKeyref](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


  trait XmlschemaXAllModelGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXAllModelGroup: Parser[xmlschema.XAllModelSequence] =
      ((opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNarrowMaxMin](x)))))) ^^ 
        { case p1 ~ p2 => xmlschema.XAllModelSequence(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq) })
  
    def parseXAllModelGroup(wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(targetNamespace, "annotation")) ~ 
      rep(((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNarrowMaxMin](x)))))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(xmlschema.XAllModelSequence(p1.headOption map { fromXML[xmlschema.XAnnotation](_) },
        p2.toSeq)) })
    
    def parsemixedXAllModelGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(targetNamespace, "annotation")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAnnotation](x)) })) ~ 
      optTextRecord ~ 
      rep(((((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNarrowMaxMin](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.toList,
        p2.toList,
        p3.flatten,
        p4.toList) })
  }

  override def buildXmlschemaXAllModelSequenceFormat = new DefaultXmlschemaXAllModelSequenceFormat {} 
  trait DefaultXmlschemaXAllModelSequenceFormat extends scalaxb.XMLFormat[xmlschema.XAllModelSequence] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XAllModelSequence] = Left("don't call me.")
    
    def writes(__obj: xmlschema.XAllModelSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.annotation map { toXML[xmlschema.XAnnotation](_, targetNamespace, Some("annotation"), __scope, false) } getOrElse {Nil},
        __obj.xallmodeloption1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XNarrowMaxMin]](x, x.namespace, x.key, __scope, false) })


  }


  trait XmlschemaXComplexTypeModelGroupFormat extends XmlschemaXTypeDefParticleGroupFormat with XmlschemaXAttrDeclsGroupFormat {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXComplexTypeModelGroup: Parser[scalaxb.DataRecord[xmlschema.XComplexTypeModelOption]] =
      (((scalaxb.ElemName(targetNamespace, "simpleContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XSimpleContent](x)))) ||| 
      ((scalaxb.ElemName(targetNamespace, "complexContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XComplexContent](x)))) ||| 
      ((opt(parseXTypeDefParticleGroup) ~ 
      (parseXAttrDeclsGroup)) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(xmlschema.XComplexTypeModelSequence1(p1,
        p2)) }))
  
    def parseXComplexTypeModelGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XComplexTypeModelOption]] =
      (((scalaxb.ElemName(targetNamespace, "simpleContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XSimpleContent](x)))) ||| 
      ((scalaxb.ElemName(targetNamespace, "complexContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XComplexContent](x)))) ||| 
      ((opt(parseXTypeDefParticleGroup) ~ 
      (parseXAttrDeclsGroup)) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(xmlschema.XComplexTypeModelSequence1(p1,
        p2)) }))
    
    def parsemixedXComplexTypeModelGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "simpleContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XSimpleContent](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "complexContent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XComplexContent](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((opt(parsemixedXTypeDefParticleGroup) ~ 
      optTextRecord ~ 
      (parsemixedXAttrDeclsGroup) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3,
        p4.toList) }))
  }

  override def buildXmlschemaXComplexTypeModelSequence1Format = new DefaultXmlschemaXComplexTypeModelSequence1Format {} 
  trait DefaultXmlschemaXComplexTypeModelSequence1Format extends scalaxb.XMLFormat[xmlschema.XComplexTypeModelSequence1] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XComplexTypeModelSequence1] = Left("don't call me.")
    
    def writes(__obj: xmlschema.XComplexTypeModelSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.arg1 map { x => toXML[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        toXML[xmlschema.XAttrDeclsSequence](__obj.arg2, targetNamespace, Some("arg2"), __scope, false))


  }


  trait XmlschemaXAttrDeclsGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXAttrDeclsGroup: Parser[xmlschema.XAttrDeclsSequence] =
      ((rep(((scalaxb.ElemName(targetNamespace, "attribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAttributable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "attributeGroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAttributeGroupRef](x))))) ~ 
      opt(scalaxb.ElemName(targetNamespace, "anyAttribute"))) ^^ 
        { case p1 ~ p2 => xmlschema.XAttrDeclsSequence(p1.toSeq,
        p2.headOption map { fromXML[xmlschema.XWildcardable](_) }) })
  
    def parseXAttrDeclsGroup(wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((rep(((scalaxb.ElemName(targetNamespace, "attribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAttributable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "attributeGroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAttributeGroupRef](x))))) ~ 
      opt(scalaxb.ElemName(targetNamespace, "anyAttribute"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(xmlschema.XAttrDeclsSequence(p1.toSeq,
        p2.headOption map { fromXML[xmlschema.XWildcardable](_) })) })
    
    def parsemixedXAttrDeclsGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((rep(((((scalaxb.ElemName(targetNamespace, "attribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAttributable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "attributeGroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAttributeGroupRef](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(targetNamespace, "anyAttribute")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XWildcardable](x)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.flatten,
        p2.toList,
        p3.toList,
        p4.toList) })
  }

  override def buildXmlschemaXAttrDeclsSequenceFormat = new DefaultXmlschemaXAttrDeclsSequenceFormat {} 
  trait DefaultXmlschemaXAttrDeclsSequenceFormat extends scalaxb.XMLFormat[xmlschema.XAttrDeclsSequence] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XAttrDeclsSequence] = Left("don't call me.")
    
    def writes(__obj: xmlschema.XAttrDeclsSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.xattrdeclsoption1 flatMap { x => toXML[scalaxb.DataRecord[xmlschema.XAttrDeclsOption1]](x, x.namespace, x.key, __scope, false) },
        __obj.anyAttribute map { toXML[xmlschema.XWildcardable](_, targetNamespace, Some("anyAttribute"), __scope, false) } getOrElse {Nil})


  }


  trait XmlschemaXParticleGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXParticleGroup: Parser[scalaxb.DataRecord[xmlschema.XParticleOption]] =
      (((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalElementable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAllable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "any")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAny](x)))))
  
    def parseXParticleGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XParticleOption]] =
      (((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalElementable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAllable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "any")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAny](x)))))
    
    def parsemixedXParticleGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalElementable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAllable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "any")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAny](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


  trait XmlschemaXNestedParticleGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXNestedParticleGroup: Parser[scalaxb.DataRecord[xmlschema.XNestedParticleOption]] =
      (((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalElementable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "any")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAny](x)))))
  
    def parseXNestedParticleGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XNestedParticleOption]] =
      (((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalElementable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "any")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAny](x)))))
    
    def parsemixedXNestedParticleGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XLocalElementable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "any")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAny](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/**  
   'complexType' uses this
*/
  trait XmlschemaXTypeDefParticleGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXTypeDefParticleGroup: Parser[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]] =
      (((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAllable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))))
  
    def parseXTypeDefParticleGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XTypeDefParticleOption]] =
      (((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAllable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))))
    
    def parsemixedXTypeDefParticleGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XGroupRef](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XAllable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "choice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "sequence")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XExplicitGroupable](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/**  
   This group is for the
   elements which can self-redefine (see <redefine> below).
*/
  trait XmlschemaXRedefinableGroupFormat extends scalaxb.AnyElemNameParser {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXRedefinableGroup: Parser[scalaxb.DataRecord[xmlschema.XRedefinableOption]] =
      (((scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelSimpleType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "complexType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelComplexType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNamedGroup](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "attributeGroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNamedAttributeGroup](x)))))
  
    def parseXRedefinableGroup(wrap: Boolean): Parser[scalaxb.DataRecord[xmlschema.XRedefinableOption]] =
      (((scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelSimpleType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "complexType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelComplexType](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNamedGroup](x)))) | 
      ((scalaxb.ElemName(targetNamespace, "attributeGroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNamedAttributeGroup](x)))))
    
    def parsemixedXRedefinableGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(targetNamespace, "simpleType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelSimpleType](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "complexType")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelComplexType](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNamedGroup](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "attributeGroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNamedAttributeGroup](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/**  
   This group is for the
   elements which occur freely at the top level of schemas.
   All of their types are based on the "annotated" type by extension.
*/
  trait XmlschemaXSchemaTopGroupFormat extends XmlschemaXRedefinableGroupFormat {  
    private val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def parseXSchemaTopGroup: Parser[scalaxb.DataRecord[Any]] =
      ((parseXRedefinableGroup(true)) ||| 
      ((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelElement](x)))) ||| 
      ((scalaxb.ElemName(targetNamespace, "attribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelAttribute](x)))) ||| 
      ((scalaxb.ElemName(targetNamespace, "notation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNotation](x)))))
  
    def parseXSchemaTopGroup(wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((parseXRedefinableGroup(true)) ||| 
      ((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelElement](x)))) ||| 
      ((scalaxb.ElemName(targetNamespace, "attribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelAttribute](x)))) ||| 
      ((scalaxb.ElemName(targetNamespace, "notation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNotation](x)))))
    
    def parsemixedXSchemaTopGroup: Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((parsemixedXRedefinableGroup) ||| 
      ((((scalaxb.ElemName(targetNamespace, "element")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelElement](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "attribute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XTopLevelAttribute](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(targetNamespace, "notation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), fromXML[xmlschema.XNotation](x)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  override def buildXmlschemaXDefRefFormat = new DefaultXmlschemaXDefRefFormat {} 
  trait DefaultXmlschemaXDefRefFormat extends scalaxb.AttributeGroupFormat[xmlschema.XDefRef] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XDefRef] = seq match {
      case node: scala.xml.Node => Right(xmlschema.XDefRef((node \ "@name").headOption map { fromXML[String](_) },
      (node \ "@ref").headOption map { fromXML[javax.xml.namespace.QName](_) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmlschema.XDefRef, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
    __obj.ref foreach { x => attr = scala.xml.Attribute(null, "ref", x.toString, attr) }
      attr
    }
  }

  override def buildXmlschemaXOccursFormat = new DefaultXmlschemaXOccursFormat {} 
  trait DefaultXmlschemaXOccursFormat extends scalaxb.AttributeGroupFormat[xmlschema.XOccurs] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XMLSchema")
    
    def reads(seq: scala.xml.NodeSeq): Either[String, xmlschema.XOccurs] = seq match {
      case node: scala.xml.Node => Right(xmlschema.XOccurs((node \ "@minOccurs").headOption map { fromXML[Int](_) } getOrElse { fromXML[Int](scala.xml.Text("1")) },
      (node \ "@maxOccurs").headOption map { fromXML[String](_) } getOrElse { fromXML[String](scala.xml.Text("1")) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmlschema.XOccurs, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.minOccurs.toString != "1") attr = scala.xml.Attribute(null, "minOccurs", __obj.minOccurs.toString, attr)
    if (__obj.maxOccurs.toString != "1") attr = scala.xml.Attribute(null, "maxOccurs", __obj.maxOccurs.toString, attr)
      attr
    }
  }


}

